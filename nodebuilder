#!/bin/sh
#
# A minimally-interactive script for launching a Bitcoin Core node
# shellcheck disable=SC2155

set -o errexit
set -o nounset

check_dpkg_lock() {
  if fuser /var/lib/dpkg/lock > /dev/null 2>&1 || fuser /var/lib/dpkg/lock-frontend > /dev/null 2>&1; then
    throw_error 'Debian package manager (dpkg) is locked by another process. Try running: ps aux | grep -i apt'
  fi
}

check_internet_status() {
  ensure_curl_dependency
  printf '%s' 'Checking internet status... '
  ( (check_internet_to_address 1.1.1.1 ||
    check_internet_to_address 1.1.0.0 ||
    check_internet_to_address 9.9.9.9 ||
    check_internet_to_address 9.9.9.11) &&
    check_internet_to_address bitcoincore.org) ||
    throw_error 'Check for active internet failed.'
  printf '%s\n' 'ok.'
}

check_internet_to_address() {
  check_internet_address=$1
  readonly CHECK_INTERNET_PORT='443'
  readonly CHECK_INTERNET_TIMEOUT='10'
  # shellcheck disable=SC2015
  command -v torsocks > /dev/null 2>&1 && [ "${TARGET_OPERATING_SYSTEM}" != 'Darwin' ] &&
    torsocks curl --silent --output /dev/null --retry 2 --connect-timeout "${CHECK_INTERNET_TIMEOUT}" "https://${check_internet_address}:${CHECK_INTERNET_PORT}" > /dev/null ||
    curl --silent --output /dev/null --retry 5 --connect-timeout "${CHECK_INTERNET_TIMEOUT}" "https://${check_internet_address}:${CHECK_INTERNET_PORT}" > /dev/null
}

clear_the_terminal() {
  if is_running_in_ci || is_running_in_container; then
    return
  elif ! [ -t 1 ]; then
    # stdout is not a terminal perhaps redirected or piped
    return
  elif command -v clear > /dev/null 2>&1; then
    clear
  elif command -v tput > /dev/null 2>&1; then
    tput clear
  else
    printf '\033c'
  fi
}

create_application_shortcuts() {
  printf '%s' 'Creating application shortcuts... '
  readonly DESKTOP_DIRECTORY="${HOME}/Desktop"
  readonly USER_DATA_DIRECTORY="${XDG_DATA_HOME:-${HOME}/.local/share}"
  readonly APPLICATIONS_DIRECTORY="${USER_DATA_DIRECTORY}/applications"
  readonly SHORTCUT_IMAGE_FILE="${USER_DATA_DIRECTORY}/images/bitcoin128.png"
  readonly SHORTCUT_IMAGE_SOURCE="${BITCOIN_CORE_REPO}/raw/v${target_bitcoin_version}/share/pixmaps/bitcoin128.png"
  readonly SHORTCUT_FILENAME='bitcoin-qt.desktop'

  [ -d "$(dirname "${SHORTCUT_IMAGE_FILE}")" ] || mkdir -p "$(dirname "${SHORTCUT_IMAGE_FILE}")"
  if ! [ -f "${SHORTCUT_IMAGE_FILE}" ]; then
    # shellcheck disable=SC2015
    if command -v torsocks > /dev/null 2>&1 && [ "${TARGET_KERNEL}" != 'Darwin' ] &&
      torsocks curl --fail --silent --show-error --location --retry 2 --head "${SHORTCUT_IMAGE_SOURCE}" | grep -q 'HTTP/[0-9.]* 200' ||
      curl --fail --silent --show-error --location --retry 5 --head "${SHORTCUT_IMAGE_SOURCE}" | grep -q 'HTTP/[0-9.]* 200'; then
      command -v torsocks > /dev/null 2>&1 && [ "${TARGET_KERNEL}" != 'Darwin' ] &&
        torsocks curl --fail --silent --show-error --location --retry 2 --output "${SHORTCUT_IMAGE_FILE}" "${SHORTCUT_IMAGE_SOURCE}" ||
        curl --fail --silent --show-error --location --retry 5 --output "${SHORTCUT_IMAGE_FILE}" "${SHORTCUT_IMAGE_SOURCE}"
    else
      throw_error "Bitcoin image file doesn't exist at ${SHORTCUT_IMAGE_SOURCE}"
    fi
  fi

  [ -d "${DESKTOP_DIRECTORY}" ] || mkdir -p "${DESKTOP_DIRECTORY}"
  [ -d "${APPLICATIONS_DIRECTORY}" ] || mkdir -p "${APPLICATIONS_DIRECTORY}"
  ## Create desktop entries on the user's Desktop and 'Show Applications' directories
  cat << EOF | tee "${APPLICATIONS_DIRECTORY}/${SHORTCUT_FILENAME}" > "${DESKTOP_DIRECTORY}/${SHORTCUT_FILENAME}"
[Desktop Entry]
Encoding=UTF-8
Version=1.0
Name=Bitcoin Core
Comment=Connect to the Bitcoin P2P Network
Comment[de]=Verbinde mit dem Bitcoin peer-to-peer Netzwerk
Comment[fr]=Connectez-vous au réseau peer-to-peer de Bitcoin
Comment[tr]=Bitcoin eşler arası ağına bağlan
Comment[es]=Conéctate a la red de Bitcoin de pares a pares
Comment[zh]=连接到比特币点对点网络
Comment[ja]=ビットコインのピア・ツー・ピアネットワークに接続
Comment[ko]=비트코인 피어 투 피어 네트워크에 연결
Comment[ru]=Подключитесь к сети Bitcoin с одноранговыми узлами
Comment[pt]=Conecte-se à rede ponto a ponto do Bitcoin
Comment[it]=Collegati alla rete peer-to-peer di Bitcoin
Comment[nl]=Verbind met het Bitcoin peer-to-peer netwerk
Comment[ar]=اتصل بشبكة بيتكوين نظير إلى نظير
Comment[pl]=Połącz z siecią typu peer-to-peer Bitcoin
Comment[sv]=Anslut till Bitcoin nätverket för peer-to-peer
Comment[hi]=बिटकॉइन पीयर-टू-पीयर नेटवर्क से कनेक्ट करें
Exec=sh -c 'if command -v bitcoin-qt >/dev/null 2>&1; then bitcoin-qt; else bitcoind --daemonwait; fi'
Terminal=false
Type=Application
Icon=${SHORTCUT_IMAGE_FILE}
MimeType=x-scheme-handler/bitcoin;
Categories=Office;Finance;P2P;Network;Qt;
StartupNotify=true
StartupWMClass=Bitcoin-qt
EOF
  chmod u+x "${APPLICATIONS_DIRECTORY}/${SHORTCUT_FILENAME}"
  chmod u+x "${DESKTOP_DIRECTORY}/${SHORTCUT_FILENAME}"
  ## Make the desktop shortcut trusted
  if is_running_in_ci || is_running_in_container; then
    :
  else
    gio set "${DESKTOP_DIRECTORY}/${SHORTCUT_FILENAME}" 'metadata::trusted' true
  fi
  printf '%s\n' 'ok.'
}

display_macos_warning() {
  if [ "${TARGET_KERNEL}" = 'Darwin' ] && [ "${TARGET_ARCHITECTURE}" = 'arm64' ]; then
    printf '%s\n%s\n' \
      'WARNING: macOS has an unpatched security vulnerability called GoFetch.' \
      '         Avoid security-critical actions, such as securing significant funds.'
    if [ "${unattended:-false}" = 'false' ] && ! is_running_in_ci; then
      printf '%s' 'PRESS ENTER to continue or press Ctrl+C to exit... '
      read -r _
    fi
  fi
}

ensure_curl_dependency() {
  if command -v dnf > /dev/null 2>&1; then
    sudo dnf install --allowerasing --assumeyes curl > /dev/null
  elif ! command -v curl > /dev/null 2>&1; then
    printf '%s' 'Installing curl depencency... '
    case "${TARGET_OPERATING_SYSTEM}" in
    alpine)
      apk --quiet add curl
      ;;
    debian | ubuntu)
      sudo apt-get install -y curl > /dev/null
      ;;
    fedora* | rhel | centos* | rocky | ol)
      sudo dnf install --allowerasing --assumeyes curl > /dev/null
      ;;
    gentoo)
      emerge --jobs "$(nproc)" --load-average "$(($(nproc) + 1))" --quiet --quiet-build --quiet-fail net-misc/curl
      ;;
    arch | endeavouros | garuda | manjaro)
      sudo pacman -Syu --needed --noconfirm curl > /dev/null
      ;;
    suse | *opensuse*)
      sudo zypper --non-interactive --quiet install curl > /dev/null
      ;;
    clear-linux-os)
      sudo swupd bundle-add curl > /dev/null
      ;;
    Darwin)
      throw_error "Please install the 'curl' dependency."
      ;;
    *)
      if command -v apk > /dev/null; then
        apk --quiet add curl
      elif command -v apt-get > /dev/null; then
        sudo apt-get -qq install -y curl > /dev/null
      elif command -v dnf > /dev/null; then
        sudo dnf install --allowerasing --assumeyes curl > /dev/null
      elif command -v pacman > /dev/null; then
        sudo pacman -Syu --needed --noconfirm curl > /dev/null
      elif command -v zypper > /dev/null; then
        sudo zypper --non-interactive --quiet install curl > /dev/null
      else
        throw_error "Package manager was not found. Please report an issue at ${NODEBUILDER_REPO}."
      fi
      ;;
    esac
    printf '%s\n' 'ok.'
  fi
  command -v curl > /dev/null 2>&1 || throw_error "Unable to install 'curl'. Please report this error at ${NODEBUILDER_REPO}."
}

ensure_sudo_dependency() {
  if ! command -v sudo > /dev/null 2>&1; then
    printf '%s' 'Installing sudo depencency... '
    case "${TARGET_OPERATING_SYSTEM}" in
    alpine)
      apk --quiet add sudo
      ;;
    debian | ubuntu)
      apt-get install -y sudo > /dev/null
      ;;
    fedora* | rhel | centos* | rocky | ol)
      dnf install --allowerasing --assumeyes sudo > /dev/null
      ;;
    gentoo)
      emerge --sync --quiet
      emerge --jobs "$(nproc)" --load-average "$(($(nproc) + 1))" --quiet --quiet-build --quiet-fail app-admin/sudo
      ;;
    arch | endeavouros | garuda | manjaro)
      pacman -Syu --needed --noconfirm sudo > /dev/null
      ;;
    suse | *opensuse*)
      zypper --non-interactive --quiet install sudo > /dev/null
      ;;
    clear-linux-os)
      swupd bundle-add sudo > /dev/null
      ;;
    *)
      if command -v apk > /dev/null; then
        apk --quiet add sudo
      elif command -v apt-get > /dev/null; then
        apt-get -qq install -y sudo > /dev/null
      elif command -v dnf > /dev/null; then
        dnf install sudo > /dev/null
      elif command -v pacman > /dev/null; then
        pacman -Syu --needed --noconfirm sudo > /dev/null
      elif command -v zypper > /dev/null; then
        zypper --non-interactive --quiet install sudo > /dev/null
      else
        throw_error "Package manager was not found. Please report an issue at ${NODEBUILDER_REPO}."
      fi
      ;;
    esac
    printf '%s\n' 'ok.'
  fi
  command -v sudo > /dev/null 2>&1 || throw_error "Unable to install 'sudo'. Please report this error at ${NODEBUILDER_REPO}."
}

ensure_xargs_dependency() {
  if ! command -v xargs > /dev/null 2>&1; then
    printf '%s' 'Installing xargs depencency... '
    case "${TARGET_OPERATING_SYSTEM}" in
    alpine)
      apk --quiet add findutils
      ;;
    debian | ubuntu)
      apt-get install -y findutils > /dev/null
      ;;
    fedora* | rhel | centos* | rocky | ol)
      dnf install --allowerasing --assumeyes findutils > /dev/null
      ;;
    gentoo)
      emerge --sync --quiet
      emerge --jobs "$(nproc)" --load-average "$(($(nproc) + 1))" --quiet --quiet-build --quiet-fail sys-apps/findutils
      ;;
    arch | endeavouros | garuda | manjaro)
      pacman -Syu --needed --noconfirm findutils > /dev/null
      ;;
    suse | *opensuse*)
      zypper --non-interactive --quiet install findutils > /dev/null
      ;;
    clear-linux-os)
      swupd bundle-add findutils > /dev/null
      ;;
    *)
      if command -v apk > /dev/null; then
        apk --quiet add findutils
      elif command -v apt-get > /dev/null; then
        apt-get -qq install -y findutils > /dev/null
      elif command -v dnf > /dev/null; then
        dnf install findutils > /dev/null
      elif command -v pacman > /dev/null; then
        pacman -Syu --needed --noconfirm findutils > /dev/null
      elif command -v zypper > /dev/null; then
        zypper --non-interactive --quiet install findutils > /dev/null
      else
        [ -f /etc/os-release ] && cat /etc/os-release
        [ -f /etc/lsb-release ] && cat /etc/lsb-release
        throw_error "Package manager was not found. Please report an issue at ${NODEBUILDER_REPO}."
      fi
      ;;
    esac
    command -v xargs > /dev/null 2>&1 ||
      throw_error "Unable to install 'xargs'. Report this error at ${NODEBUILDER_REPO}."
    printf '%s\n' 'ok.'
  fi
}

get_cursor_column() {
  stored_stty_settings=$(stty -g)
  # Set raw mode, no echo, immediate read
  stty raw -echo min 0 time 10
  # Send ANSII escape code to request cursor position
  printf "\033[6n" > /dev/tty
  # System will print the cursor's row and column
  IFS=';' read -r _ stty_column
  stty "${stored_stty_settings}"
  printf '%s' "${stty_column}"
}

test_get_cursor_column() {
  # Test when cursor is at the start of a line
  printf '\n'
  col=$(get_cursor_column)
  [ "${col}" -ne 1 ] && throw_error "Failed: Expected 1, got ${col}"

  # Test when cursor is at the end of the string 'test'
  printf '\n%s' 'test'
  col=$(get_cursor_column)
  [ "${col}" -ne 5 ] && throw_error "Failed: Expected 5, got ${col}"

  printf '%s\n' 'All tests passed'
  return 0
}

get_free_space_in_mib() {
  if [ "${TARGET_KERNEL}" = 'Darwin' ]; then
    /bin/df -m "${HOME}" | awk '{print $4}' | sed 1d
  else
    df --output=avail --block-size='1MiB' "${HOME}" | sed 1d
  fi
}

get_memory_metric_in_mib() {
  metric_to_query="$1"
  awk -v metric="${metric_to_query}" \
    -v kib_mib_factor="${KIB_TO_MIB}" \
    '$0 ~ metric { printf "%d \n", $2 / kib_mib_factor }' /proc/meminfo
}

get_operating_system() {
  if [ "${TARGET_KERNEL}" = 'Darwin' ]; then
    printf '%s\n' 'Darwin'
  else
    readonly OS_RELEASE_ID="$(grep '^ID=' /etc/os-release | cut -d= -f2)"
    readonly OS_RELEASE_ID_LIKE="$(grep '^ID_LIKE=' /etc/os-release | cut -d= -f2)"
    if [ -n "${OS_RELEASE_ID}" ] || [ -n "${OS_RELEASE_ID_LIKE}" ]; then
      printf '%s\n' "${OS_RELEASE_ID_LIKE:-${OS_RELEASE_ID}}"
    else
      throw_error 'Failed to determine OS release type'
    fi
  fi
}

# shellcheck disable=SC2317
handle_exit() {
  [ -n "${TEMP_DIRECTORY:-}" ] && rm -rf -- "${TEMP_DIRECTORY:?}"/
}

# shellcheck disable=SC2317
handle_sigint() {
  printf '\n%s\n' 'Detected Ctrl+C. Exiting.'
  handle_exit
  exit 0
}

install_build_dependencies() {
  case "${TARGET_OPERATING_SYSTEM}" in
  alpine)
    install_build_dependencies_apk
    ;;
  debian | ubuntu)
    install_build_dependencies_aptget
    ;;
  fedora* | rhel | centos* | rocky | ol)
    install_build_dependencies_dnf
    ;;
  gentoo)
    install_build_dependencies_emerge
    ;;
  arch | endeavouros | garuda | manjaro)
    install_build_dependencies_pacman
    ;;
  suse | *opensuse*)
    install_build_dependencies_zypper
    ;;
  clear-linux-os)
    install_build_dependencies_swupd
    ;;
  Darwin)
    install_build_dependencies_darwin
    ;;
  *)
    install_build_command_function=''
    for package_manager in \
      apk \
      apt-get \
      dnf \
      emerge \
      pacman \
      swupd \
      zypper; do
      if command -v "${package_manager}" > /dev/null; then
        install_build_command_function="install_build_dependencies_$(echo "${package_manager}" | tr -d '-')"
        break
      fi
    done
    if [ -n "${install_build_command_function}" ]; then
      "${install_build_command_function}"
    else
      printf '%s\n  %s\n' 'failed.' 'Unable to determine build dependencies. Attempting to compile without verifying dependencies.'
    fi
    ;;
  esac
}

install_build_dependencies_apk() {
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_apk.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."
  printf '%s\n' "${dependencies}" | xargs apk --quiet add |
    grep -v 'ICU with non-English locales' -A2 -B1 || true
}

install_build_dependencies_aptget() {
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_aptget.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."
  printf '%s\n' "${dependencies}" | xargs sudo DEBIAN_FRONTEND=noninteractive apt-get -qq install --assume-yes --no-install-recommends > /dev/null
  # TODO: Remove gcc-12 installation on next line when Ubuntu updates the default version of gcc to support C++ 20 features. Bitcoin Core requires gcc with support for C++ 20 features.
  DEBIAN_FRONTEND=noninteractive sudo apt-get -qq install --assume-yes --no-install-recommends gcc-12
}

install_build_dependencies_darwin() {
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_darwin.txt"
  #TODO: wrap this command with torsocks-curl with curl fallback
  sudo printf '' && NONINTERACTIVE=1 /bin/bash -c "$(curl --fail --silent --show-error --location --retry 5 \
    https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" > /dev/null 2>&1
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."
  printf '%s\n' "${dependencies}" | xargs brew install --quiet > /dev/null
}

install_build_dependencies_dnf() {
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_dnf.txt"
  readonly OS_MAJOR_VERSION_ID="$(grep "^VERSION_ID=" /etc/os-release | cut -d= -f2 | tr -d '"' | cut -d. -f1)"

  case "$(grep "^ID=" /etc/os-release | cut -d= -f2 | tr -d '"')" in
  amzn)
    throw_error "Building from source on Amazon Linux is unsupported."
    ;;
  rhel)
    sudo subscription-manager identity > /dev/null 2>&1 ||
      throw_error "Register your RHEL subscription with 'sudo subscription-manager subscribe'."
    sudo dnf config-manager --enable "rhel-${OS_MAJOR_VERSION_ID}-for-${TARGET_ARCHITECTURE}-appstream-rpms" ||
      throw_error "Failed to enable EPEL release rhel-${OS_MAJOR_VERSION_ID}-for-${TARGET_ARCHITECTURE}-appstream-rpms."
    ;;
  *) ;;
  esac

  dnf list installed epel-release > /dev/null 2>&1 ||
    sudo dnf --assumeyes install "https://dl.fedoraproject.org/pub/epel/epel-release-latest-${OS_MAJOR_VERSION_ID}.noarch.rpm"

  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."

  printf '%s\n' "${dependencies}" | xargs sudo dnf install --assumeyes > /dev/null
}

install_build_dependencies_emerge() {
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_emerge.txt"
  printf '\n'
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error 'The list of dependencies is empty.'
  if ! printf '%s\n' "${dependencies}" | xargs emerge --autounmask-write \
    --jobs "$(nproc)" --load-average "$(($(nproc) + 1))" --quiet --quiet-build --quiet-fail; then
    etc-update --automode -5
    emerge --update --jobs "$(nproc)" --load-average "$(($(nproc) + 1))" --quiet --quiet-build --quiet-fail --deep --newuse @world
    # Run the install command again
    printf '%s\n' "${dependencies}" | xargs emerge --autounmask-write \
      --jobs "$(nproc)" --load-average "$(($(nproc) + 1))" --quiet --quiet-build --quiet-fail
  fi
}

install_build_dependencies_pacman() {
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_pacman.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."
  printf '%s\n' "${dependencies}" | xargs sudo pacman -Syu --needed --noconfirm --quiet > /dev/null 2> "${STDERR_COMPILE_LOG_FILE}"
  grep -v 'skipping' "${STDERR_COMPILE_LOG_FILE}" >&2 || true
}

install_build_dependencies_swupd() {
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_swupd.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."
  printf '%s\n' "${dependencies}" | xargs sudo swupd bundle-add --quiet > /dev/null
}

install_build_dependencies_zypper() {
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_zypper.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."
  printf '%s\n' "${dependencies}" | xargs sudo zypper --non-interactive --quiet install
  export CXX=g++-13
}

install_runtime_dependencies() {
  printf '%s' 'Ensuring runtime dependencies... '
  case "${TARGET_OPERATING_SYSTEM}" in
  alpine)
    install_runtime_dependencies_apk
    ;;
  debian | ubuntu)
    install_runtime_dependencies_aptget
    ;;
  fedora* | rhel | centos* | rocky | ol)
    install_runtime_dependencies_dnf
    ;;
  gentoo)
    install_runtime_dependencies_emerge
    ;;
  arch | endeavouros | garuda | manjaro)
    install_runtime_dependencies_pacman
    ;;
  suse | *opensuse*)
    install_runtime_dependencies_zypper
    ;;
  clear-linux-os)
    install_runtime_dependencies_swupd
    ;;
  Darwin)
    install_runtime_dependencies_darwin
    ;;
  *)
    install_runtime_command_function=''
    for package_manager in \
      apk \
      apt-get \
      dnf \
      emerge \
      pacman \
      swupd \
      zypper; do
      if command -v "${package_manager}" > /dev/null; then
        install_runtime_command_function="install_runtime_dependencies_$(echo "${package_manager}" | tr -d '-')"
        break
      fi
    done

    if [ -n "${install_runtime_command_function}" ]; then
      "${install_runtime_command_function}"
    else
      throw_error 'Unknown package manager. This version of Linux is not supported.'
    fi
    ;;
  esac
  printf '%s\n' 'ok.'
}

install_runtime_dependencies_apk() {
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_apk.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs sudo apk --quiet add
}

install_runtime_dependencies_aptget() {
  check_dpkg_lock
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_aptget.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs sudo DEBIAN_FRONTEND=noninteractive apt-get -qq install --assume-yes --no-install-recommends > /dev/null
}

install_runtime_dependencies_darwin() {
  if ! command -v git > /dev/null 2>&1; then
    printf '%s\n%s' 'not found.' 'Installing git via the Xcode Command Line Tools... '
    # These steps were taken from: https github com/Homebrew/install/blob/aceed88a4a062e2b41dc40a7428c71309fce14c9/install.sh#L831
    # TODO: find a way to install only the git binary, not all the Xcode tools. Unattended git installation shouldn't take 20+ lines of code.
    readonly CLT_INSTALL_IN_PROGRESS='/tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress'
    sudo touch "${CLT_INSTALL_IN_PROGRESS}"
    readonly CLT_LABEL_COMMAND="/usr/sbin/softwareupdate -l | grep -B 1 -E 'Command Line Tools' | awk -F'*' '/^ *\\*/ {print \$2}' | sed -e 's/^ *Label: //' -e 's/^ *//' | sort -V | tail -n1 | tr -d '\n'"
    readonly CLT_LABEL="$(/bin/sh -c "${CLT_LABEL_COMMAND}")"
    if [ -n "${CLT_LABEL}" ]; then
      sudo /usr/sbin/softwareupdate -i "${CLT_LABEL}" > /dev/null
    else
      throw_error 'Failed to install git. Cannot find a compatible Xcode Command Line Tools package.'
    fi
    sudo rm "${CLT_INSTALL_IN_PROGRESS}"

    if command -v git > /dev/null 2>&1; then
      printf '%s\n' 'ok.'
    elif [ "${unattended}" = 'true' ]; then
      throw_error 'Failed to install Xcode Command Line Tools. Try re-running without -u/--unattended or manually installing git.'
    else
      printf '%s\n%s\n' 'failed.' 'Installing the Command Line Tools (expect a popup window).'
      /usr/bin/xcode-select --install
      printf '%s\n' "PRESS ENTER after you've completed the installation via the popup window."
      read -r _
      if ! command -v git > /dev/null 2>&1; then
        throw_error 'Failed to install git via the Xcode Command Line Tools. Try manually installing git'
      fi
    fi
  fi
}

install_runtime_dependencies_dnf() {
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_dnf.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs sudo dnf --assumeyes --quiet install > /dev/null
}

install_runtime_dependencies_emerge() {
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_emerge.txt"
  printf '\n'
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs emerge --autounmask-write --jobs "$(nproc)" --load-average "$(($(nproc) + 1))" --quiet --quiet-build --quiet-fail
}

install_runtime_dependencies_pacman() {
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_pacman.txt"
  readonly STDERR_DEPENDENCIES_LOG_FILE="${TEMP_DIRECTORY}/stderr_runtime_dependencies_log"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs sudo pacman -Syu --needed --noconfirm --quiet > /dev/null 2> "${STDERR_DEPENDENCIES_LOG_FILE}"
  grep -v 'skipping' "${STDERR_DEPENDENCIES_LOG_FILE}" >&2 || true
  rm "${STDERR_DEPENDENCIES_LOG_FILE}"
}

install_runtime_dependencies_swupd() {
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_swupd.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs sudo swupd bundle-add --quiet > /dev/null
}

install_runtime_dependencies_zypper() {
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_zypper.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs sudo zypper --non-interactive --quiet install > /dev/null
}

install_system_updates() {
  printf '%s' 'Performing a system upgrade... '
  case "${TARGET_OPERATING_SYSTEM}" in
  alpine)
    install_system_updates_apk
    ;;
  debian | ubuntu)
    install_system_updates_aptget
    ;;
  fedora* | rhel | centos* | rocky | ol)
    install_system_updates_dnf
    ;;
  gentoo)
    install_system_updates_emerge
    ;;
  arch | endeavouros | garuda | manjaro)
    install_system_updates_pacman
    ;;
  suse | *opensuse*)
    install_system_updates_zypper
    ;;
  clear-linux-os)
    install_system_updates_swupd
    ;;
  *)
    if command -v apk > /dev/null; then
      install_system_updates_apk
    elif command -v apt-get > /dev/null; then
      install_system_updates_aptget
    elif command -v dnf > /dev/null; then
      install_system_updates_dnf
    elif command -v emerge > /dev/null; then
      install_system_updates_emerge
    elif command -v pacman > /dev/null; then
      install_system_updates_pacman
    elif command -v swupd > /dve/null; then
      install_system_updates_swupd
    elif command -v zypper > /dev/null; then
      install_system_updates_zypper
    else
      throw_error 'This version of Linux is not supported.'
    fi
    ;;
  esac

  # Stop running if the Docker container base image is outdated
  if [ -f /var/run/reboot-required ] && is_running_in_container; then
    throw_error "The Docker base image is outdated. Please open an issue at ${NODEBUILDER_REPO}."
  # Reboot the system unless it's running in CI/CD
  elif [ -f /var/run/reboot-required ] && ! is_running_in_ci; then
    printf '\n%s\n%s\n' 'REBOOT IS REQUIRED to upgrade the following packages:' "$(cat /var/run/reboot-required.pkgs)"
    if [ "${unattended}" = 'false' ]; then
      printf '\n%s' 'PRESS ENTER to reboot or press Ctrl+C to exit... '
      read -r _
    fi
    printf '%s\n' 'Rebooting.'
    sudo reboot
    exit 0
  fi
  printf '%s\n' 'ok.'
}

install_system_updates_apk() {
  apk update --quiet && apk upgrade --quiet
}

install_system_updates_aptget() {
  check_dpkg_lock
  sudo apt-get -qq update && sudo NEEDRESTART_MODE=a apt-get -qq dist-upgrade --assume-yes > /dev/null 2>&1
}

install_system_updates_dnf() {
  sudo dnf clean all && sudo dnf --assumeyes --quiet upgrade > /dev/null
}

install_system_updates_emerge() {
  readonly GENTOO_EBUILD_REPOSITORY='/var/db/repos/gentoo'
  printf '\n'
  [ -d "${GENTOO_EBUILD_REPOSITORY}" ] || mkdir -p "${GENTOO_EBUILD_REPOSITORY}"
  emerge --depclean --quiet
  emerge --update --jobs "$(nproc)" --load-average "$(($(nproc) + 1))" --quiet --quiet-build --quiet-fail --deep --newuse @world
  emerge --depclean --quiet
}

install_system_updates_pacman() {
  sudo pacman -Syu --noconfirm --quiet > /dev/null
}

install_system_updates_swupd() {
  sudo swupd update --quiet > /dev/null
}

install_system_updates_zypper() {
  sudo zypper --non-interactive --quiet dist-upgrade > /dev/null
}

is_running_in_ci() {
  if [ "${CI:-false}" = 'true' ]; then
    return 0
  else
    return 1 #1=false
  fi
}

is_running_in_container() {
  if [ -f /proc/1/cgroup ] && grep -q 'docker\|lxc\|actions_job' /proc/1/cgroup; then
    return 0
  elif [ -f /proc/1/mountinfo ] && grep -q 'docker\|lxc\|actions_job' /proc/1/mountinfo; then
    return 0
  else
    return 1
  fi
}

is_valid_bitcoin_version() {
  [ -z "$1" ] && throw_error 'No arguemnt passed into is_valid_bitcoin_version().'
  bitcoin_version_to_check="$1"
  for version in ${VALID_BITCOIN_VERSION_LIST}; do
    if [ "${bitcoin_version_to_check}" = "${version}" ]; then
      return 0
    fi
  done
  return 1
}

log_error() {
  printf '\n'
  printf '%s\n' "[$(date +'%Y-%m-%dT%H:%M:%S')] ERROR: $*" >&2
}

print_usage() {
  printf '%s\n\n' "Usage: $0 [options]"
  printf '%s\n' 'Options:'
  printf '%s\n' '-b, --bitcoin-version   Specify the Bitcoin version'
  printf '%s\n' '-c, --compile           Build Bitcoin from source'
  printf '%s\n' '-h, --help              Display this help message'
  printf '%s\n' '-p, --prune             Set a prune value in MiB'
  printf '%s\n' '-t, --test              Run unit tests on functions'
  printf '%s\n' '-u, --unattended        Run in non-interactive mode'
}

run_unit_tests() {
  printf '%s' 'Testing get_cursor_column...'
  test_get_cursor_column
  printf '%s\n' 'PASS'
  return 0
}

set_bitcoin_core_option() {
  option="$1"
  value="$2"
  if [ -f "${BITCOIN_CORE_CONFIG_FILE:?}" ]; then
    sed -i.bak "/^${option}=/d" "${BITCOIN_CORE_CONFIG_FILE:?}"
    rm "${BITCOIN_CORE_CONFIG_FILE:?}.bak"
  else
    install -m 600 /dev/null "${BITCOIN_CORE_CONFIG_FILE:?}"
  fi
  printf '%s\n' "${option}=${value}" >> "${BITCOIN_CORE_CONFIG_FILE:?}"
}

# This function sets a Bitcoin Core option in the configuration file if it's not already set.
set_if_unset_bitcoin_core_option() {
  option="$1"
  value="$2"
  # create a blank config file if it doesn't exist
  if [ ! -f "${BITCOIN_CORE_CONFIG_FILE:?}" ]; then
    install -m 600 /dev/null "${BITCOIN_CORE_CONFIG_FILE:?}"
  fi
  # add the new option if not already set
  grep -q -i "^${option}=" "${BITCOIN_CORE_CONFIG_FILE:?}" ||
    printf '%s\n' "${option}=${value}" >> "${BITCOIN_CORE_CONFIG_FILE:?}"
}

throw_error() {
  if [ $# -eq 1 ]; then
    log_error "$1"
  elif [ $# -gt 1 ]; then
    log_error "$@"
  else
    log_error "Unknown error thrown."
  fi
  handle_exit
  exit 1
}

# This list excludes vulnerable versions, e.g. CVE-2015-6031 and CVE-2018-17144
readonly VALID_BITCOIN_VERSION_LIST='0.9.5 0.10.0 0.10.1 0.10.2 0.10.3 0.10.4 \
    0.11.0 0.11.1 0.11.2 0.12.0 0.12.1 0.13.0 0.13.1 0.13.2 \0.14.3 0.15.2 \
    0.16.3 0.17.0 0.17.0.1 0.17.1 0.17.2 0.18.0 0.18.1 0.19.0 0.19.0.1 0.19.1 \
    0.20.0 0.20.1 0.20.2 0.21.0 0.21.1 0.21.2 22.0 22.1 23.0 23.1 23.2 24.0 \
    24.0.1 24.1 24.2 25.0 25.1 25.2 26.0 26.1 26.2 27.0 27.1'

target_bitcoin_version='27.1'

compile_bitcoin='false'
prune_value='-1'
unattended='false'
unit_tests='false'

while [ $# -gt 0 ]; do
  case "$1" in
  -b | --bitcoin-version)
    if [ $# -eq 1 ]; then
      throw_error '-b/--bitcoin-version requires an argument.'
    fi
    if is_valid_bitcoin_version "$2"; then
      target_bitcoin_version="$2"
    else
      throw_error "The Bitcoin version '$2' is not valid. Please use a value such as '27.0' from https://bitcoincore.org/bin/."
    fi
    shift
    ;;
  -c | --compile)
    compile_bitcoin='true'
    ;;
  -h | --help)
    print_usage
    exit 0
    ;;
  -p | --prune)
    if [ $# -eq 1 ]; then
      throw_error '-p/--prune requires an argument'
    fi
    case $2 in
    *[!0-9]*) # if $2 contains any non-numeric characters
      throw_error "The prune value '$2' must be a positive integer or zero to disable pruning"
      ;;
    *) ;;
    esac
    if [ "$2" -gt 0 ] && [ "$2" -lt 550 ]; then
      throw_error "The prune value '$2' must be at least 550 (MiB) or zero to disable pruning"
    fi
    prune_value="$2"
    shift
    ;;
  -t | --test)
    unit_tests='true'
    ;;
  -u | --unattended)
    unattended='true'
    ;;
  *)
    printf '%s\n%s\n' "Error: '$1' is invalid." 'Use -h or --help for available options.'
    exit 1
    ;;
  esac
  shift
done

[ "${unit_tests}" = 'true' ] && run_unit_tests

trap 'if [ $? -eq 0 ]; then handle_exit; else throw_error "Unhandled error at line ${LINENO:-}."; fi' EXIT
trap handle_sigint INT

readonly BYTES_TO_KIB=1024
readonly KIB_TO_MIB="${BYTES_TO_KIB}"
readonly MIB_TO_GIB="${BYTES_TO_KIB}"

readonly TEMP_DIRECTORY="$(mktemp -d)"
readonly TARGET_ARCHITECTURE="$(uname -m)"
readonly TARGET_KERNEL="$(uname -s)"
readonly TARGET_OPERATING_SYSTEM="$(get_operating_system)"

readonly BITCOIN_CORE_REPO='https://github.com/bitcoin/bitcoin'
readonly NODEBUILDER_REPO='https://github.com/bitcoin-tools/nodebuilder'
readonly NODEBUILDER_DEPENDENCIES_TAG='v1.6.0'
readonly DEPENDENCIES_BASE_URL="${NODEBUILDER_REPO}/raw/${NODEBUILDER_DEPENDENCIES_TAG}/resources/dependencies"

ensure_sudo_dependency
ensure_xargs_dependency

if is_running_in_ci ||
  is_running_in_container ||
  sudo --validate --noninteractive > /dev/null 2>&1; then
  :
else
  printf '%s\n' 'Please enter your sudo password if requested.'
  sudo --validate
fi

clear_the_terminal
case "${TARGET_KERNEL}" in
Linux)
  TARGET_BITCOIN_TARBALL_OS='linux-gnu'
  BITCOIN_DATA_DIRECTORY="${HOME}/.bitcoin"
  printf '%s\n' "Detected: running Linux."
  is_running_in_container && printf '%s\n' 'Detected: running in Docker.'
  ;;
Darwin)
  TARGET_BITCOIN_TARBALL_OS='apple-darwin'
  BITCOIN_DATA_DIRECTORY="${HOME}/Library/Application Support/Bitcoin"
  printf '%s\n' "Detected: running macOS."
  display_macos_warning
  ;;
MINGW*)
  throw_error 'Windows is not supported. Instead, use WSL (Windows Subsystem for Linux).'
  ;;
*)
  throw_error "Your operating system is not supported. Please open an issue at ${NODEBUILDER_REPO}."
  ;;
esac

check_internet_status
is_running_in_ci || [ "${TARGET_KERNEL}" = 'Darwin' ] || install_system_updates
install_runtime_dependencies

readonly TARGET_BITCOIN_TARBALL_OS
readonly BITCOIN_DATA_DIRECTORY
readonly BITCOIN_CORE_CONFIG_FILE="${BITCOIN_DATA_DIRECTORY}/bitcoin.conf"
readonly BITCOIN_CORE_DEBUG_LOG_FILE="${BITCOIN_DATA_DIRECTORY}/debug.log"

printf '%s' "Checking for Bitcoin Core ${target_bitcoin_version}... "
if command -v bitcoind > /dev/null 2>&1; then
  current_bitcoin_version="$(bitcoind --version 2> /dev/null | head -1 | cut -c23-)"
else
  current_bitcoin_version=''
fi

# If version is like 'xx.yy.zz' or 'xx.yy' or 'xx', pad it as 'xx.yy.zz.0'
case "${current_bitcoin_version}" in
'' | *[.]*[.]*[.]*)
  CURRENT_BITCOIN_VERSION_PADDED="${current_bitcoin_version}"
  ;;
*[.]*[.]*)
  CURRENT_BITCOIN_VERSION_PADDED="${current_bitcoin_version}.0"
  ;;
*[.]*)
  CURRENT_BITCOIN_VERSION_PADDED="${current_bitcoin_version}.0.0"
  ;;
*)
  CURRENT_BITCOIN_VERSION_PADDED="${current_bitcoin_version}.0.0.0"
  ;;
esac
readonly CURRENT_BITCOIN_VERSION_PADDED

case "${target_bitcoin_version}" in
'' | *[.]*[.]*[.]*)
  TARGET_BITCOIN_VERSION_PADDED="${target_bitcoin_version}"
  ;;
*[.]*[.]*)
  TARGET_BITCOIN_VERSION_PADDED="${target_bitcoin_version}.0"
  ;;
*[.]*)
  TARGET_BITCOIN_VERSION_PADDED="${target_bitcoin_version}.0.0"
  ;;
*)
  TARGET_BITCOIN_VERSION_PADDED="${target_bitcoin_version}.0.0.0"
  ;;
esac
readonly TARGET_BITCOIN_VERSION_PADDED

if [ "${CURRENT_BITCOIN_VERSION_PADDED}" = "${TARGET_BITCOIN_VERSION_PADDED}" ]; then
  printf '%s\n' 'ok.'
elif [ "${compile_bitcoin:-false}" = 'true' ] ||
  [ "${TARGET_OPERATING_SYSTEM}" = 'alpine' ] ||
  [ "${TARGET_OPERATING_SYSTEM}" = 'gentoo' ]; then
  printf '%s\n  %s' 'no.' 'Ensuring compile dependencies... '
  readonly COMPILE_DIRECTORY="${TEMP_DIRECTORY}/compile_bitcoin"
  readonly STDERR_COMPILE_LOG_FILE="${TEMP_DIRECTORY}/stderr_install.log"
  install_build_dependencies
  printf '%s\n  %s' 'ok.' 'Downloading Bitcoin source code... '
  # shellcheck disable=SC2015
  command -v torsocks > /dev/null 2>&1 && [ "${TARGET_KERNEL}" != 'Darwin' ] &&
    torsocks git clone --branch "v${target_bitcoin_version}" --depth 1 --quiet -c advice.detachedHead=false "${BITCOIN_CORE_REPO}.git" "${COMPILE_DIRECTORY}" ||
    git clone --branch "v${target_bitcoin_version}" --depth 1 --quiet -c advice.detachedHead=false "${BITCOIN_CORE_REPO}.git" "${COMPILE_DIRECTORY}"
  cd "${COMPILE_DIRECTORY}"/
  printf '%s\n  %s' 'ok.' 'Analyzing hardware configuration... '
  ./autogen.sh > /dev/null 2> "${STDERR_COMPILE_LOG_FILE}"
  grep -v 'build-aux' "${STDERR_COMPILE_LOG_FILE}" >&2 || true
  printf '%s\n  %s' 'ok.' 'Configuring the build environment... '
  if [ "${TARGET_KERNEL}" = 'Darwin' ]; then
    ./configure CC=clang CXX=clang++ --without-bdb --enable-suppress-external-warnings > /dev/null
  else
    ./configure --without-bdb --enable-suppress-external-warnings > /dev/null
  fi
  printf '%s\n  %s' 'ok.' 'Compiling source code, please wait... '
  if [ "${TARGET_OPERATING_SYSTEM}" = 'Darwin' ]; then
    compile_jobs_count="$(($(sysctl -n hw.physicalcpu) + 1))"
  else
    compile_jobs_count="$(($(nproc) + 1))"
  fi
  make --jobs "${compile_jobs_count}" > /dev/null 2>&1
  printf '%s\n  %s' 'ok.' 'Running compile checks, please wait... '
  make --jobs "${compile_jobs_count}" check > /dev/null 2> "${STDERR_COMPILE_LOG_FILE}"
  # exclude the two lines before and after 'Ran 3 tests in ' in make check's stdout
  sed -n '1N;2N;/Ran 3 tests in /{N;N;d;};P;N;D' "${STDERR_COMPILE_LOG_FILE}" >&2
  printf '%s\n  %s' 'ok.' 'Installing Bitcoin Core... '
  make install > /dev/null 2>&1 || sudo make install > /dev/null
  printf '%s\n' 'ok.'
  cd - > /dev/null
  rm "${STDERR_COMPILE_LOG_FILE}"
  rm -rf "${COMPILE_DIRECTORY:?}"/
  current_bitcoin_version="${target_bitcoin_version}"
else
  printf '%s\n' 'no.'
  readonly BITCOIN_CORE_EXTRACT_DIR="${TEMP_DIRECTORY}/bitcoin-core"
  readonly BITCOIN_INSTALL_BIN_SOURCE="${BITCOIN_CORE_EXTRACT_DIR}/bin"
  readonly BITCOIN_INSTALL_LIB_SOURCE="${BITCOIN_CORE_EXTRACT_DIR}/lib"
  readonly BITCOIN_INSTALL_INCLUDE_SOURCE="${BITCOIN_CORE_EXTRACT_DIR}/include"
  readonly BITCOIN_INSTALL_MAN_SOURCE="${BITCOIN_CORE_EXTRACT_DIR}/share/man/man1"
  readonly BITCOIN_INSTALL_DESTINATION='/usr/local'
  readonly BITCOIN_INSTALL_BIN_DESTINATION="${BITCOIN_INSTALL_DESTINATION}/bin"
  readonly BITCOIN_INSTALL_LIB_DESTINATION="${BITCOIN_INSTALL_DESTINATION}/lib"
  readonly BITCOIN_INSTALL_INCLUDE_DESTINATION="${BITCOIN_INSTALL_DESTINATION}/include"
  readonly BITCOIN_INSTALL_MAN_DESTINATION="${BITCOIN_INSTALL_DESTINATION}/share/man/man1"

  readonly BITCOIN_TARBALL_FILENAME="bitcoin-${target_bitcoin_version}-${TARGET_ARCHITECTURE}-${TARGET_BITCOIN_TARBALL_OS}.tar.gz"
  readonly BITCOIN_TARBALL_DESTINATION_PATH="${HOME}/Downloads/${BITCOIN_TARBALL_FILENAME}"

  if ! [ -f "${BITCOIN_TARBALL_DESTINATION_PATH}" ]; then
    readonly BITCOIN_SOURCE="https://bitcoincore.org/bin/bitcoin-core-${target_bitcoin_version}"
    readonly BITCOIN_TARBALL_FILE_SOURCE="${BITCOIN_SOURCE}/${BITCOIN_TARBALL_FILENAME}"
    readonly BITCOIN_HASH_FILENAME='SHA256SUMS'
    readonly BITCOIN_HASH_FILE_SOURCE="${BITCOIN_SOURCE}/${BITCOIN_HASH_FILENAME}"
    readonly GPG_SIGNATURES_FILENAME='SHA256SUMS.asc'
    readonly GPG_SIGNATURES_FILE_SOURCE="${BITCOIN_SOURCE}/${GPG_SIGNATURES_FILENAME}"
    readonly GPG_GOOD_SIGNATURES_REQUIRED='7'
    readonly GUIX_SIGS_REPO='https://github.com/bitcoin-core/guix.sigs'
    readonly BITCOIN_TARBALL_TEMPORARY_DIRECTORY="${TEMP_DIRECTORY}/${BITCOIN_TARBALL_FILENAME}"
    readonly BITCOIN_HASH_FILE="${TEMP_DIRECTORY}/${BITCOIN_HASH_FILENAME}"
    readonly GPG_SIGNATURES_FILE="${TEMP_DIRECTORY}/${GPG_SIGNATURES_FILENAME}"
    readonly GUIX_SIGS_TEMPORARY_DIRECTORY="${TEMP_DIRECTORY}/guix.sigs"
    readonly GUIX_SIGS_DESTINATION_DIRECTORY="${HOME}/Downloads/guix.sigs"
    printf '  %s' 'Downloading Bitcoin Core... '
    if command -v torsocks > /dev/null 2>&1 && [ "${TARGET_KERNEL}" != 'Darwin' ]; then
      torsocks curl --fail --silent --show-error --location --retry 2 --output "${BITCOIN_HASH_FILE}" "${BITCOIN_HASH_FILE_SOURCE}" ||
        curl --fail --silent --show-error --location --retry 5 --output "${BITCOIN_HASH_FILE}" "${BITCOIN_HASH_FILE_SOURCE}"
      torsocks curl --fail --silent --show-error --location --retry 2 --output "${GPG_SIGNATURES_FILE}" "${GPG_SIGNATURES_FILE_SOURCE}" ||
        curl --fail --silent --show-error --location --retry 5 --output "${GPG_SIGNATURES_FILE}" "${GPG_SIGNATURES_FILE_SOURCE}"
      torsocks curl --fail --silent --show-error --location --retry 2 --output "${BITCOIN_TARBALL_TEMPORARY_DIRECTORY}" "${BITCOIN_TARBALL_FILE_SOURCE}" ||
        curl --fail --silent --show-error --location --retry 5 --output "${BITCOIN_TARBALL_TEMPORARY_DIRECTORY}" "${BITCOIN_TARBALL_FILE_SOURCE}"
    else
      curl --fail --silent --show-error --location --retry 5 --output "${BITCOIN_HASH_FILE}" "${BITCOIN_HASH_FILE_SOURCE}"
      curl --fail --silent --show-error --location --retry 5 --output "${GPG_SIGNATURES_FILE}" "${GPG_SIGNATURES_FILE_SOURCE}"
      curl --fail --silent --show-error --location --retry 5 --output "${BITCOIN_TARBALL_TEMPORARY_DIRECTORY}" "${BITCOIN_TARBALL_FILE_SOURCE}"
    fi
    printf '%s\n' 'ok.'

    printf '  %s' 'Validating the checksum... '
    cd "${TEMP_DIRECTORY}"/
    if command -v sha256sum > /dev/null; then
      readonly SHA256_CHECK="$(grep "${BITCOIN_TARBALL_FILENAME}" "${BITCOIN_HASH_FILENAME}" | sha256sum --check 2> /dev/null)"
    elif command -v shasum > /dev/null; then
      readonly SHA256_CHECK="$(grep "${BITCOIN_TARBALL_FILENAME}" "${BITCOIN_HASH_FILENAME}" | shasum -a 256 --check 2> /dev/null)"
    else
      throw_error "Either sha256sum or shasum must on PATH. Please open an issue at ${NODEBUILDER_REPO}."
    fi
    cd "${HOME}"/
    case "${SHA256_CHECK}" in
    *'OK'*) ;;
    *)
      throw_error "INVALID CHECKSUM. The download has failed. This script cannot continue due to security concerns. Please review the temporary file ${TEMP_DIRECTORY}/${BITCOIN_HASH_FILE}."
      ;;
    esac
    printf '%s\n' 'ok.'

    printf '  %s' 'Validating the signatures... '
    if [ -d "${GUIX_SIGS_DESTINATION_DIRECTORY}"/ ]; then
      gpg --quiet --import "${GUIX_SIGS_DESTINATION_DIRECTORY}"/builder-keys/*.gpg
    else
      # shellcheck disable=SC2015
      command -v torsocks > /dev/null 2>&1 && [ "${TARGET_KERNEL}" != 'Darwin' ] &&
        torsocks git clone --depth 1 --quiet "${GUIX_SIGS_REPO}.git" "${GUIX_SIGS_TEMPORARY_DIRECTORY}" ||
        git clone --depth 1 --quiet "${GUIX_SIGS_REPO}.git" "${GUIX_SIGS_TEMPORARY_DIRECTORY}"
      gpg --quiet --import "${GUIX_SIGS_TEMPORARY_DIRECTORY}"/builder-keys/*.gpg
    fi
    readonly GPG_GOOD_SIGNATURE_COUNT="$(gpg --verify "${GPG_SIGNATURES_FILE}" 2>&1 | grep -c '^gpg: Good signature from ')"
    pgrep '^gpg-agent$' > /dev/null && gpgconf --kill gpg-agent
    pgrep '^keyboxd$' > /dev/null && gpgconf --kill keyboxd
    if [ "${GPG_GOOD_SIGNATURE_COUNT}" -ge "${GPG_GOOD_SIGNATURES_REQUIRED}" ]; then
      printf '%s\n' "${GPG_GOOD_SIGNATURE_COUNT} good."
      [ -d "$(dirname "${BITCOIN_TARBALL_DESTINATION_PATH}")" ] || mkdir -p "$(dirname "${BITCOIN_TARBALL_DESTINATION_PATH}")"
      mv "${BITCOIN_TARBALL_TEMPORARY_DIRECTORY}" "${BITCOIN_TARBALL_DESTINATION_PATH}"
      [ -d "${GUIX_SIGS_DESTINATION_DIRECTORY}"/ ] || mv "${GUIX_SIGS_TEMPORARY_DIRECTORY}" "${GUIX_SIGS_DESTINATION_DIRECTORY}"
      rm "${BITCOIN_HASH_FILE}"
      rm "${GPG_SIGNATURES_FILE}"
    else
      throw_error "INVALID SIGNATURES. The download has failed. This script cannot continue due to security concerns. Please review the temporary file ${TEMP_DIRECTORY}/${GPG_SIGNATURES_FILE}."
    fi
  fi

  printf '  %s' 'Extracting Bitcoin Core... '
  [ -d "${BITCOIN_CORE_EXTRACT_DIR}"/ ] || mkdir "${BITCOIN_CORE_EXTRACT_DIR}"
  tar -xzf "${BITCOIN_TARBALL_DESTINATION_PATH}" -C "${BITCOIN_CORE_EXTRACT_DIR}"/ --strip-components=1
  printf '%s\n' 'ok.'

  printf '  %s' 'Running the unit tests... '
  if [ "${TARGET_ARCHITECTURE}" = 'arm64' ]; then
    codesign -s - "${BITCOIN_INSTALL_BIN_SOURCE}"/test_bitcoin
  fi
  readonly UNIT_TEST_RESPONSE="$("${BITCOIN_INSTALL_BIN_SOURCE}"/test_bitcoin 2>&1)"
  case "${UNIT_TEST_RESPONSE}" in
  *'No errors detected'*) ;;
  *)
    printf '\n%s\n' "${UNIT_TEST_RESPONSE}"
    throw_error 'Unit tests failed.'
    ;;
  esac
  printf '%s\n  %s' 'ok.' 'Installing Bitcoin Core... '
  [ -d "${BITCOIN_INSTALL_LIB_DESTINATION}" ] ||
    mkdir -p "${BITCOIN_INSTALL_LIB_DESTINATION}" 2> /dev/null ||
    sudo mkdir "${BITCOIN_INSTALL_LIB_DESTINATION}" ||
    throw_error "Unable to create directory ${BITCOIN_INSTALL_LIB_DESTINATION}."
  case "${TARGET_KERNEL}" in
  Linux)
    sudo cp "${BITCOIN_INSTALL_LIB_SOURCE}"/libbitcoinconsensus.so.0.0.0 "${BITCOIN_INSTALL_LIB_DESTINATION}"/libbitcoinconsensus.so.0.0.0
    (cd "${BITCOIN_INSTALL_LIB_DESTINATION}"/ && { sudo ln -s -f libbitcoinconsensus.so.0.0.0 libbitcoinconsensus.so.0 || { sudo rm -f libbitcoinconsensus.so.0 && sudo ln -s libbitcoinconsensus.so.0.0.0 libbitcoinconsensus.so.0; }; })
    (cd "${BITCOIN_INSTALL_LIB_DESTINATION}"/ && { sudo ln -s -f libbitcoinconsensus.so.0.0.0 libbitcoinconsensus.so || { sudo rm -f libbitcoinconsensus.so && sudo ln -s libbitcoinconsensus.so.0.0.0 libbitcoinconsensus.so; }; })
    PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin:/sbin' ldconfig -n "${BITCOIN_INSTALL_LIB_DESTINATION}"
    ;;
  Darwin)
    sudo cp "${BITCOIN_INSTALL_LIB_SOURCE}"/libbitcoinconsensus.0.dylib "${BITCOIN_INSTALL_LIB_DESTINATION}"/libbitcoinconsensus.0.dylib
    (cd "${BITCOIN_INSTALL_LIB_DESTINATION}"/ && { sudo ln -s -f libbitcoinconsensus.0.dylib libbitcoinconsensus.dylib || { sudo rm -f libbitcoinconsensus.dylib && sudo ln -s libbitcoinconsensus.0.dylib libbitcoinconsensus.dylib; }; })
    sudo update_dyld_shared_cache

    if [ "${TARGET_ARCHITECTURE}" = 'arm64' ]; then
      for bitcoin_executable in bitcoin-cli bitcoin-qt bitcoin-tx bitcoin-util bitcoin-wallet bitcoind; do
        codesign -s - "${BITCOIN_INSTALL_BIN_SOURCE}/${bitcoin_executable}"
      done
    fi
    ;;
  *)
    throw_error "UNSUPPORTED OS - unable to install Bitcoin Core."
    ;;
  esac

  [ -d "${BITCOIN_INSTALL_BIN_DESTINATION}" ] ||
    mkdir -p "${BITCOIN_INSTALL_BIN_DESTINATION}" 2> /dev/null ||
    sudo mkdir "${BITCOIN_INSTALL_BIN_DESTINATION}" ||
    throw_error "Unable to create directory ${BITCOIN_INSTALL_BIN_DESTINATION}."
  for bitcoin_executable in bitcoind bitcoin-qt bitcoin-cli bitcoin-tx bitcoin-util bitcoin-wallet test_bitcoin; do
    sudo install -c "${BITCOIN_INSTALL_BIN_SOURCE}/${bitcoin_executable}" "${BITCOIN_INSTALL_BIN_DESTINATION}/"
  done

  [ -d "${BITCOIN_INSTALL_INCLUDE_DESTINATION}" ] ||
    mkdir -p "${BITCOIN_INSTALL_INCLUDE_DESTINATION}" 2> /dev/null ||
    sudo mkdir "${BITCOIN_INSTALL_INCLUDE_DESTINATION}" ||
    throw_error "Unable to create directory ${BITCOIN_INSTALL_INCLUDE_DESTINATION}."
  sudo install -c -m 644 "${BITCOIN_INSTALL_INCLUDE_SOURCE}"/bitcoinconsensus.h "${BITCOIN_INSTALL_INCLUDE_DESTINATION}/"

  [ -d "${BITCOIN_INSTALL_MAN_DESTINATION}" ] ||
    mkdir -p "${BITCOIN_INSTALL_MAN_DESTINATION}" 2> /dev/null ||
    sudo mkdir -p "${BITCOIN_INSTALL_MAN_DESTINATION}" ||
    throw_error "Unable to create directory ${BITCOIN_INSTALL_MAN_DESTINATION}."
  for man_page in bitcoind.1 bitcoin-qt.1 bitcoin-cli.1 bitcoin-tx.1 bitcoin-util.1 bitcoin-wallet.1; do
    sudo install -c -m 644 "${BITCOIN_INSTALL_MAN_SOURCE}/${man_page}" "${BITCOIN_INSTALL_MAN_DESTINATION}/"
  done
  printf '%s\n' 'ok.'

  printf '  %s' 'Removing installation files... '
  rm -r "${BITCOIN_CORE_EXTRACT_DIR:?}/"
  rm -r "${TEMP_DIRECTORY:?}/"
  printf '%s\n' 'ok.'
fi

[ "${TARGET_KERNEL}" != 'Darwin' ] && create_application_shortcuts

# If bitcoin.conf doesn't already exist, use default settings
[ -d "${BITCOIN_DATA_DIRECTORY}"/ ] || mkdir "${BITCOIN_DATA_DIRECTORY}"/
if [ ! -f "${BITCOIN_CORE_CONFIG_FILE}" ]; then
  printf '%s' 'Setting the default node behavior... '
  is_running_in_ci && set_bitcoin_core_option 'debug' 'net'
  set_bitcoin_core_option 'mempoolfullrbf' '1'
  set_bitcoin_core_option 'server' '1'
  printf '%s\n' 'ok.'
fi

case "${TARGET_KERNEL}" in
Darwin) ;; #TODO: Add macOS memory check
*)
  printf '%s' 'Checking the memory on your system... '
  readonly PHYSICAL_MEMORY_TOTAL_IN_MIB="$(get_memory_metric_in_mib 'MemTotal')"
  readonly PHYSICAL_MEMORY_FREE_IN_MIB="$(get_memory_metric_in_mib 'MemAvailable')"
  readonly SWAP_MEMORY_TOTAL_IN_MIB="$(get_memory_metric_in_mib 'SwapTotal')"
  readonly SWAP_MEMORY_FREE_IN_MIB="$(get_memory_metric_in_mib 'SwapFree')"
  readonly MEMORY_TOTAL_IN_MIB=$((PHYSICAL_MEMORY_TOTAL_IN_MIB + SWAP_MEMORY_TOTAL_IN_MIB))
  readonly MEMORY_FREE_IN_MIB=$((PHYSICAL_MEMORY_FREE_IN_MIB + SWAP_MEMORY_FREE_IN_MIB))
  printf '%0.1f of %0.1f GiB free.\n' \
    "$(awk -v mem_free_mib="${MEMORY_FREE_IN_MIB}" -v mib_gib_factor="${MIB_TO_GIB}" 'BEGIN{printf "%f\n", mem_free_mib / mib_gib_factor}')" \
    "$(awk -v mem_total_mib="${MEMORY_TOTAL_IN_MIB}" -v mib_gib_factor="${MIB_TO_GIB}" 'BEGIN{printf "%f\n", mem_total_mib / mib_gib_factor}')"

  if [ "${MEMORY_TOTAL_IN_MIB}" -le $((1 * MIB_TO_GIB)) ] || [ "${MEMORY_FREE_IN_MIB}" -le '32' ]; then
    printf '%s' 'Configuring for minimal memory usage... '
    set_if_unset_bitcoin_core_option 'dbcache' '4'
    set_if_unset_bitcoin_core_option 'maxmempool' '5'
    set_if_unset_bitcoin_core_option 'maxconnections' '4'
    [ "${TARGET_KERNEL}" = 'Linux' ] && export MALLOC_ARENA_MAX=1
    printf '%s\n' 'ok.'
  elif [ "${MEMORY_TOTAL_IN_MIB}" -le $((2 * MIB_TO_GIB)) ] || [ "${MEMORY_FREE_IN_MIB}" -le '64' ]; then
    printf '%s' 'Configuring for reduced memory usage... '
    set_if_unset_bitcoin_core_option 'dbcache' '100'
    set_if_unset_bitcoin_core_option 'maxmempool' '50'
    set_if_unset_bitcoin_core_option 'maxconnections' '10'
    [ "${TARGET_KERNEL}" = 'Linux' ] && export MALLOC_ARENA_MAX=1
    printf '%s\n' 'ok.'
  elif [ "${MEMORY_TOTAL_IN_MIB}" -le $((4 * MIB_TO_GIB)) ] || [ "${MEMORY_FREE_IN_MIB}" -le '128' ]; then
    printf '%s' 'Configuring for conservative memory usage... '
    set_if_unset_bitcoin_core_option 'dbcache' '225'
    set_if_unset_bitcoin_core_option 'maxmempool' '150'
    printf '%s\n' 'ok.'
  fi
  ;;
esac

printf '%s' 'Checking data already synced... '
readonly BITCOIN_CORE_BLOCKS_DIRECTORY="${BITCOIN_DATA_DIRECTORY}/blocks"
if [ -d "${BITCOIN_CORE_BLOCKS_DIRECTORY}"/ ]; then
  if [ "${TARGET_KERNEL}" = 'Darwin' ]; then
    readonly INITIAL_BLOCKS_SIZE_IN_MIB="$(du -d0 -m "${BITCOIN_CORE_BLOCKS_DIRECTORY}" | cut -f1)"
  else
    readonly INITIAL_BLOCKS_SIZE_IN_MIB="$(du -d0 --block-size='1MiB' "${BITCOIN_CORE_BLOCKS_DIRECTORY}" | cut -f1)"
  fi
else
  readonly INITIAL_BLOCKS_SIZE_IN_MIB=0
fi
readonly BITCOIN_CORE_CHAINSTATE_DIRECTORY="${BITCOIN_DATA_DIRECTORY}/chainstate"
if [ -d "${BITCOIN_CORE_CHAINSTATE_DIRECTORY}"/ ]; then
  if [ "${TARGET_KERNEL}" = 'Darwin' ]; then
    readonly INITIAL_CHAINSTATE_SIZE_IN_MIB="$(du -d0 -m "${BITCOIN_CORE_CHAINSTATE_DIRECTORY}" | cut -f1)"
  else
    readonly INITIAL_CHAINSTATE_SIZE_IN_MIB="$(du -d0 --block-size='1MiB' "${BITCOIN_CORE_CHAINSTATE_DIRECTORY}" | cut -f1)"
  fi
else
  readonly INITIAL_CHAINSTATE_SIZE_IN_MIB=0
fi
readonly INITIAL_DATA_ALREADY_SYNCED_IN_MIB=$((INITIAL_BLOCKS_SIZE_IN_MIB + INITIAL_CHAINSTATE_SIZE_IN_MIB))
printf '%s\n' "$((INITIAL_DATA_ALREADY_SYNCED_IN_MIB / MIB_TO_GIB)) GiB."

printf '%s' 'Checking free space in home directory... '
free_space_in_mib="$(get_free_space_in_mib)"
printf '%s\n' "$((free_space_in_mib / MIB_TO_GIB)) GiB."

## This constant will need to be adjusted over time as the chain grows
## or need to find how to generate this dynamically in a trustless way.
## The lower this number is, the more likely disk space errors during IBD.
## The higher this number is, the more likely a node will be to prune.
## The sweet spot is about 50 to 100 GB more than the size of blocks/ + chainstate/,
## which, as of June 2023, is around 522 GiB.
readonly ARCHIVAL_NODE_REQUIRED_DISK_IN_GIB='686'
readonly ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB=$((ARCHIVAL_NODE_REQUIRED_DISK_IN_GIB * MIB_TO_GIB))

# check if the user wants to disable pruning
if [ "${prune_value}" -eq 0 ]; then
  if [ "$((free_space_in_mib + INITIAL_DATA_ALREADY_SYNCED_IN_MIB))" -lt "${ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB}" ]; then
    throw_error "Not enough storage to disable pruning. Free up ${ARCHIVAL_NODE_REQUIRED_DISK_IN_GIB} GiB or use a positive value less than $((free_space_in_mib + INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) \(MiB\)."
  fi
  printf '  %s' 'Configuring with the disabled prune option... '
  set_bitcoin_core_option 'prune' "${prune_value}"
  printf '%s\n' 'ok.'
# check if the user passed in a prune value
elif [ "${prune_value}" -gt 0 ]; then
  if [ "$((free_space_in_mib + INITIAL_DATA_ALREADY_SYNCED_IN_MIB))" -lt "${prune_value}" ]; then
    throw_error "Prune value ${prune_value} too large. Run without setting prune or use a value less than $((free_space_in_mib + INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) \(MiB\)."
  fi
  printf '  %s' "Configuring with the ${prune_value} MiB prune option... "
  set_bitcoin_core_option 'prune' "${prune_value}"
  printf '%s\n' 'ok.'
# check that a prune value doesn't already exist in the config file
elif ! grep -q -i '^prune=' "${BITCOIN_CORE_CONFIG_FILE}"; then
  if [ "${free_space_in_mib}" -ge $((ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB - INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) ]; then
    printf '  %s\n' 'Your node will run as an unpruned full node.'
    set_bitcoin_core_option 'prune' '0'
  elif [ "${free_space_in_mib}" -lt $((ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB / 80 - INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) ]; then
    throw_error 'You are too low on disk space to run Bitcoin Core.'
  else
    if [ "${free_space_in_mib}" -lt $((ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB / 40 - INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) ]; then
      printf '  %s\n  %s\n' 'Your disk space is low.' 'Setting blocks-only mode and the minimum 0.55 GiB prune.'
      set_bitcoin_core_option 'blocksonly' '1'
      readonly PRUNE_AMOUNT_IN_MIB='550'
    else
      if [ "${free_space_in_mib}" -lt $((ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB / 12 - INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) ]; then
        readonly PRUNE_RATIO=20
      elif [ "${free_space_in_mib}" -lt $((ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB / 4 - INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) ]; then
        readonly PRUNE_RATIO=40
      elif [ "${free_space_in_mib}" -lt $((ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB * 3 / 4 - INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) ]; then
        readonly PRUNE_RATIO=60
      else
        readonly PRUNE_RATIO=80
      fi
      readonly PRUNE_AMOUNT_IN_MIB=$((free_space_in_mib * PRUNE_RATIO / 100))
      printf '  Pruning to %d GiB (%d%% of the free space).\n  You can change this in ~/.bitcoin/bitcoin.conf.\n' "$((PRUNE_AMOUNT_IN_MIB / MIB_TO_GIB))" "${PRUNE_RATIO}"
    fi
    set_bitcoin_core_option 'prune' "${PRUNE_AMOUNT_IN_MIB}"
  fi
fi

printf '%s' 'Starting Bitcoin Core... '
if is_running_in_ci ||
  is_running_in_container ||
  ! command -v bitcoin-qt > /dev/null 2>&1; then
  bitcoind --daemonwait > /dev/null
elif [ "${TARGET_KERNEL}" = 'Darwin' ]; then
  nohup bitcoin-qt > /dev/null 2>&1 < /dev/null &
else
  setsid bitcoin-qt > /dev/null 2>&1 < /dev/null &
fi

printf '%s\n  %s' 'ok.' 'Checking the RPC status... '
readonly BITCOIN_RPC_TIMEOUT=60
if ! bitcoin-cli --rpcwait --rpcwaittimeout="${BITCOIN_RPC_TIMEOUT}" getrpcinfo > /dev/null; then
  throw_error "RPC communication failed after ${BITCOIN_RPC_TIMEOUT} seconds"
fi
printf '%s\n' 'ok.'

readonly SLEEP_TIME='10'
blockchain_info=$(bitcoin-cli --rpcwait getblockchaininfo)
ibd_status=$(echo "${blockchain_info}" | jq '.initialblockdownload')

if [ "${ibd_status}" = 'true' ]; then
  if ! is_running_in_container; then
    printf '%s' 'Disabling system sleep, suspend, and hibernate... '
    if [ "${TARGET_KERNEL}" = 'Darwin' ]; then
      caffeinate -sw "$(cat "${BITCOIN_DATA_DIRECTORY}/bitcoind.pid")" &
    else
      sudo systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target > /dev/null 2>&1
    fi
    printf '%s\n%s\n%s' \
      'ok.' \
      "Close this Terminal window by clicking on the 'X'." \
      "This screen will refresh in ${SLEEP_TIME} seconds."
  fi
  sleep_count=1
  while [ "${sleep_count}" -le "${SLEEP_TIME}" ]; do
    sleep 1
    printf '%s' '.'
    sleep_count=$((sleep_count + 1))
  done
  printf '\n'
else
  printf '  %s\n' 'Your node has already synced the blockchain.'
fi

while [ "${ibd_status}" = 'true' ]; do
  blocks=$(echo "${blockchain_info}" | jq '.blocks')
  headers=$(echo "${blockchain_info}" | jq '.headers')
  last_block_time=$(echo "${blockchain_info}" | jq '.time')
  size_on_disk_in_mib=$(($(echo "${blockchain_info}" | jq '.size_on_disk') / BYTES_TO_KIB / KIB_TO_MIB))
  sync_progress=$(echo "${blockchain_info}" | jq '.verificationprogress')

  # Handle case of early sync (e^-8 or e^-9) by replacing scientific notation with decimal percent
  case "${sync_progress}" in
  *e*) sync_progress_percent='0.0000001' ;;
  *) sync_progress_percent="$(awk -v prog="${sync_progress}" 'BEGIN{printf "%f\n", prog * 100}')" ;;
  esac

  free_space_in_mib="$(get_free_space_in_mib)"

  clear_the_terminal
  if [ "${headers}" -eq 0 ]; then
    headers_presync_height="$(grep 'Pre-synchronizing blockheaders' "${BITCOIN_CORE_DEBUG_LOG_FILE}" | tail -1 | cut -d, -f2 | cut -d: -f2 | cut -d'(' -f1 | cut -d' ' -f2)"
    headers_presync_progress_percent="$(grep 'Pre-synchronizing blockheaders' "${BITCOIN_CORE_DEBUG_LOG_FILE}" | tail -1 | cut -d~ -f2 | cut -d% -f1)"
    printf '%s\n' 'Syncing the block headers (first pass).'
    printf 'Headers presynced:          %s\n' "${headers_presync_height}"
    printf 'Headers presync prog str:   %s %% DEBUG ONLY\n' "${headers_presync_progress_percent}"
    printf 'Headers presync progress:   %.2f %%\n' "${headers_presync_progress_percent}"
  elif [ "${blocks}" -eq 0 ]; then
    headers_sync_progress_percent="$(grep 'Synchronizing blockheaders' "${BITCOIN_CORE_DEBUG_LOG_FILE}" | tail -1 | cut -d~ -f2 | cut -d% -f1)"
    printf '%s\n' 'Syncing the block headers (second pass).'
    printf 'Headers synced:             %d\n' "${headers}"
    printf 'Headers sync progress:      %.2f %%\n' "${headers_sync_progress_percent}"
  else
    printf 'Sync progress:              %.3f %%\n' "${sync_progress_percent}"
    printf 'Blocks remaining:           %d\n' "$((headers - blocks))"

    if [ "${TARGET_KERNEL}" = 'Darwin' ]; then
      current_chain_tip_timestamp="$(/bin/date -r "${last_block_time}" | cut -c 5-)"
    else
      current_chain_tip_timestamp="$(date -d @"${last_block_time}" | cut -c 5-)"
    fi
    printf 'Current chain tip:          %s\n' "${current_chain_tip_timestamp}"

    printf '%s' 'Chain sync size:            '
    if [ "${size_on_disk_in_mib}" -gt "${MIB_TO_GIB}" ]; then
      printf '%d GiB\n' "$((size_on_disk_in_mib / MIB_TO_GIB))"
    else
      printf '%d MiB\n' "${size_on_disk_in_mib}"
    fi
  fi

  printf '%s' 'Disk free space:            '
  if [ "${free_space_in_mib}" -gt "${MIB_TO_GIB}" ]; then
    printf '%d GiB\n' "$((free_space_in_mib / MIB_TO_GIB))"
  else
    printf '%d MiB\n' "${free_space_in_mib}"
  fi

  if [ "${size_on_disk_in_mib}" -ge 1 ] && (is_running_in_ci || is_running_in_container); then
    printf '%s\n' 'The blockchain download is progressing. Exiting the script.'
    exit 0
  fi

  printf '%s\n\n' 'Synchronizing can take weeks on a slow connection.'
  printf '%s\n' "Close this Terminal window by clicking on the 'X'."
  printf '%s' "This screen will refresh in ${SLEEP_TIME} seconds."
  sleep "${SLEEP_TIME}"

  blockchain_info=$(bitcoin-cli --rpcwait getblockchaininfo)
  printf '\n'
  ibd_status=$(echo "${blockchain_info}" | jq '.initialblockdownload')
done

printf '%s\n' 'This script has completed successfully.'
exit 0
