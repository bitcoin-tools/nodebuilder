#!/bin/sh
#
# A minimally-interactive script for launching a Bitcoin Core node

set -o errexit
set -o nounset

check_dpkg_lock()
{
  if fuser /var/lib/dpkg/lock > /dev/null 2>&1 || fuser /var/lib/dpkg/lock-frontend > /dev/null 2>&1; then
    throw_error 'Debian package manager (dpkg) is locked by another process. Try running: ps aux | grep -i apt'
  fi
}

check_internet_status()
{
  ensure_curl_dependency
  log_info 'Checking for internet.'
  ( (check_internet_to_address 1.1.1.1 ||
    check_internet_to_address 1.1.0.0 ||
    check_internet_to_address 9.9.9.9 ||
    check_internet_to_address 9.9.9.11) &&
    check_internet_to_address bitcoincore.org) ||
    throw_error 'Internet checks failed.'
  log_info 'Internet checks passed.'
}

check_internet_to_address()
{
  check_internet_address=$1
  readonly CHECK_INTERNET_PORT='443'
  readonly CHECK_INTERNET_TIMEOUT_SECONDS='10'
  # shellcheck disable=SC2015
  command -v torsocks > /dev/null 2>&1 && [ "${TARGET_OPERATING_SYSTEM}" != 'Darwin' ] &&
    torsocks curl --silent --output /dev/null --retry 2 --connect-timeout "${CHECK_INTERNET_TIMEOUT_SECONDS}" "https://${check_internet_address}:${CHECK_INTERNET_PORT}" > /dev/null ||
    curl --silent --output /dev/null --retry 5 --connect-timeout "${CHECK_INTERNET_TIMEOUT_SECONDS}" "https://${check_internet_address}:${CHECK_INTERNET_PORT}" > /dev/null
}

clear_the_terminal()
{
  if is_running_in_ci || is_running_in_container; then
    return
  elif [ ! -t 1 ]; then
    # stdout is not a terminal perhaps redirected or piped
    return
  elif command -v clear > /dev/null 2>&1; then
    clear
  elif command -v tput > /dev/null 2>&1; then
    tput clear
  else
    printf '\033c'
  fi
}

compile_bitcoin_from_source()
{
  log_info 'Ensuring compile dependencies.'
  readonly COMPILE_DIRECTORY="${TEMP_DIRECTORY}/compile_bitcoin"
  readonly STDERR_COMPILE_LOG_FILE="${TEMP_DIRECTORY}/stderr_install.log"
  install_build_dependencies

  log_info 'Downloading Bitcoin source code.'
  # shellcheck disable=SC2015
  command -v torsocks > /dev/null 2>&1 &&
    [ "${TARGET_KERNEL}" != 'Darwin' ] &&
    torsocks git clone --branch "v${target_bitcoin_version}" --depth 1 --quiet -c advice.detachedHead=false "${BITCOIN_CORE_REPO}.git" "${COMPILE_DIRECTORY}" ||
    git clone --branch "v${target_bitcoin_version}" --depth 1 --quiet -c advice.detachedHead=false "${BITCOIN_CORE_REPO}.git" "${COMPILE_DIRECTORY}"
  cd "${COMPILE_DIRECTORY}"/

  log_info 'Analyzing hardware configuration.'
  command -v autoreconf > /dev/null 2>&1 ||
    throw_error "Build dependencies failed to install. Manually install 'autoconf' and try again."
  ./autogen.sh > /dev/null 2> "${STDERR_COMPILE_LOG_FILE}"
  grep -v 'build-aux' "${STDERR_COMPILE_LOG_FILE}" >&2 || true

  log_info 'Configuring the build environment.'
  case "${TARGET_KERNEL}" in
    Darwin)
      ./configure CC=clang CXX=clang++ --without-bdb --enable-suppress-external-warnings > /dev/null
      ;;
    FreeBSD)
      ./configure --without-bdb --enable-suppress-external-warnings MAKE=gmake > /dev/null
      ;;
    OpenBSD)
      ./configure --without-bdb --enable-suppress-external-warnings MAKE=gmake > /dev/null 2>&1
      ;;
    *)
      ./configure --without-bdb --enable-suppress-external-warnings > /dev/null
      ;;
  esac
  log_info 'Compiling source code. Please wait.'
  case "${TARGET_KERNEL}" in
    FreeBSD | OpenBSD)
      gmake --jobs "${SYS_CORES_PLUS_ONE}" > /dev/null 2>&1
      ;;
    *)
      make --jobs "${SYS_CORES_PLUS_ONE}" > /dev/null 2>&1
      ;;
  esac

  log_info 'Running compile checks. Please wait.'
  case "${TARGET_KERNEL}" in
    FreeBSD | OpenBSD)
      gmake --jobs "${SYS_CORES_PLUS_ONE}" check > /dev/null 2> "${STDERR_COMPILE_LOG_FILE}"
      ;;
    *)
      make --jobs "${SYS_CORES_PLUS_ONE}" check > /dev/null 2> "${STDERR_COMPILE_LOG_FILE}"
      ;;
  esac
  # exclude the two lines before and after 'Ran 3 tests in ' in make check's stdout
  sed -n '1N;2N;/Ran 3 tests in /{N;N;d;};P;N;D' "${STDERR_COMPILE_LOG_FILE}" >&2

  log_info "Installing Bitcoin Core ${target_bitcoin_version}."
  case "${TARGET_KERNEL}" in
    FreeBSD | OpenBSD)
      gmake install > /dev/null 2>&1 || sudo gmake install > /dev/null
      ;;
    *)
      make install > /dev/null 2>&1 || sudo make install > /dev/null
      ;;
  esac

  cd - > /dev/null
  rm "${STDERR_COMPILE_LOG_FILE}"
  rm -rf "${COMPILE_DIRECTORY:?}"/
}

create_application_shortcuts()
{
  log_info 'Creating application shortcuts.'
  readonly DESKTOP_DIRECTORY="${HOME}/Desktop"
  readonly USER_DATA_DIRECTORY="${XDG_DATA_HOME:-${HOME}/.local/share}"
  readonly APPLICATIONS_DIRECTORY="${USER_DATA_DIRECTORY}/applications"
  readonly SHORTCUT_IMAGE_FILE="${USER_DATA_DIRECTORY}/images/bitcoin128.png"
  readonly SHORTCUT_IMAGE_SOURCE="${BITCOIN_CORE_REPO}/raw/v${target_bitcoin_version}/share/pixmaps/bitcoin128.png"
  readonly SHORTCUT_FILENAME='bitcoin-qt.desktop'
  readonly OLD_SHORTCUT_FILENAME='bitcoin_core.desktop'

  [ -d "$(dirname "${SHORTCUT_IMAGE_FILE}")" ] || mkdir -p "$(dirname "${SHORTCUT_IMAGE_FILE}")"
  if [ ! -f "${SHORTCUT_IMAGE_FILE}" ]; then
    # shellcheck disable=SC2015
    if command -v torsocks > /dev/null 2>&1 && [ "${TARGET_KERNEL}" != 'Darwin' ] &&
      torsocks curl --fail --silent --show-error --location --retry 2 --head "${SHORTCUT_IMAGE_SOURCE}" | grep -q 'HTTP/[0-9.]* 200' ||
      curl --fail --silent --show-error --location --retry 5 --head "${SHORTCUT_IMAGE_SOURCE}" | grep -q 'HTTP/[0-9.]* 200'; then
      command -v torsocks > /dev/null 2>&1 && [ "${TARGET_KERNEL}" != 'Darwin' ] &&
        torsocks curl --fail --silent --show-error --location --retry 2 --output "${SHORTCUT_IMAGE_FILE}" "${SHORTCUT_IMAGE_SOURCE}" ||
        curl --fail --silent --show-error --location --retry 5 --output "${SHORTCUT_IMAGE_FILE}" "${SHORTCUT_IMAGE_SOURCE}"
    else
      throw_error "Bitcoin image file doesn't exist at ${SHORTCUT_IMAGE_SOURCE}"
    fi
  fi

  for shortcut_directory in "${DESKTOP_DIRECTORY}" "${APPLICATIONS_DIRECTORY}"; do
    [ -d "${shortcut_directory}" ] || mkdir -p "${shortcut_directory}"
    [ -f "${shortcut_directory}/${OLD_SHORTCUT_FILENAME}" ] && rm "${shortcut_directory}/${OLD_SHORTCUT_FILENAME}"
  done

  ## Create desktop entries on the user's Desktop and 'Show Applications' directories
  cat << EOF | tee "${APPLICATIONS_DIRECTORY}/${SHORTCUT_FILENAME}" > "${DESKTOP_DIRECTORY}/${SHORTCUT_FILENAME}"
[Desktop Entry]
Encoding=UTF-8
Version=1.0
Name=Bitcoin Core
Comment=Connect to the Bitcoin P2P Network
Comment[de]=Verbinde mit dem Bitcoin peer-to-peer Netzwerk
Comment[fr]=Connectez-vous au réseau peer-to-peer de Bitcoin
Comment[tr]=Bitcoin eşler arası ağına bağlan
Comment[es]=Conéctate a la red de Bitcoin de pares a pares
Comment[zh]=连接到比特币点对点网络
Comment[ja]=ビットコインのピア・ツー・ピアネットワークに接続
Comment[ko]=비트코인 피어 투 피어 네트워크에 연결
Comment[ru]=Подключитесь к сети Bitcoin с одноранговыми узлами
Comment[pt]=Conecte-se à rede ponto a ponto do Bitcoin
Comment[it]=Collegati alla rete peer-to-peer di Bitcoin
Comment[nl]=Verbind met het Bitcoin peer-to-peer netwerk
Comment[ar]=اتصل بشبكة بيتكوين نظير إلى نظير
Comment[pl]=Połącz z siecią typu peer-to-peer Bitcoin
Comment[sv]=Anslut till Bitcoin nätverket för peer-to-peer
Comment[hi]=बिटकॉइन पीयर-टू-पीयर नेटवर्क से कनेक्ट करें
Exec=sh -c 'if command -v bitcoin-qt > /dev/null 2>&1; then bitcoin-qt --datadir="${BITCOIN_DATA_DIRECTORY}"; else bitcoind --daemonwait --datadir="${BITCOIN_DATA_DIRECTORY}"; fi'
Terminal=false
Type=Application
Icon=${SHORTCUT_IMAGE_FILE}
MimeType=x-scheme-handler/bitcoin;
Categories=Office;Finance;P2P;Network;Qt;
StartupNotify=true
StartupWMClass=org.bitcoin.bitcoin-qt
EOF
  chmod u+x "${APPLICATIONS_DIRECTORY}/${SHORTCUT_FILENAME}"
  chmod u+x "${DESKTOP_DIRECTORY}/${SHORTCUT_FILENAME}"
  ## Make the desktop shortcut trusted
  if is_running_in_ci || is_running_in_container; then
    :
  elif command -v gio > /dev/null 2>&1 &&
    gio set "${DESKTOP_DIRECTORY}/${SHORTCUT_FILENAME}" 'metadata::trusted' true 2> /dev/null; then
    :
  else
    log_warning "If the desktop shortcut is failing, please open an issue at ${NODEBUILDER_REPO}."
  fi
}

display_macos_warning()
{
  log_warning 'macOS has an unpatched security vulnerability called GoFetch.'
  log_warning 'Avoid security-critical actions, such as securing significant funds.'
  if [ "${unattended:-false}" = 'false' ] && ! is_running_in_ci; then
    log_info 'PRESS ENTER to continue or press Ctrl+C to exit.'
    read -r _
  fi
}

bitcoin_tarball_download()
{
  log_info 'Downloading Bitcoin Core.'
  if command -v torsocks > /dev/null 2>&1 && [ "${TARGET_KERNEL}" != 'Darwin' ]; then
    torsocks curl --fail --silent --show-error --location --retry 2 --output "${BITCOIN_HASH_FILE}" "${BITCOIN_HASH_FILE_SOURCE}" ||
      curl --fail --silent --show-error --location --retry 5 --output "${BITCOIN_HASH_FILE}" "${BITCOIN_HASH_FILE_SOURCE}"
    torsocks curl --fail --silent --show-error --location --retry 2 --output "${GPG_SIGNATURES_FILE}" "${GPG_SIGNATURES_FILE_SOURCE}" ||
      curl --fail --silent --show-error --location --retry 5 --output "${GPG_SIGNATURES_FILE}" "${GPG_SIGNATURES_FILE_SOURCE}"
    torsocks curl --fail --silent --show-error --location --retry 2 --output "${BITCOIN_TARBALL_TEMPORARY_PATH}" "${BITCOIN_TARBALL_FILE_SOURCE}" ||
      curl --fail --silent --show-error --location --retry 5 --output "${BITCOIN_TARBALL_TEMPORARY_PATH}" "${BITCOIN_TARBALL_FILE_SOURCE}"
  else
    curl --fail --silent --show-error --location --retry 5 --output "${BITCOIN_HASH_FILE}" "${BITCOIN_HASH_FILE_SOURCE}"
    curl --fail --silent --show-error --location --retry 5 --output "${GPG_SIGNATURES_FILE}" "${GPG_SIGNATURES_FILE_SOURCE}"
    curl --fail --silent --show-error --location --retry 5 --output "${BITCOIN_TARBALL_TEMPORARY_PATH}" "${BITCOIN_TARBALL_FILE_SOURCE}"
  fi
}

bitcoin_tarball_download_validate()
{
  readonly BITCOIN_SOURCE="https://bitcoincore.org/bin/bitcoin-core-${target_bitcoin_version}"
  readonly BITCOIN_TARBALL_FILE_SOURCE="${BITCOIN_SOURCE}/${BITCOIN_TARBALL_FILENAME}"
  readonly BITCOIN_HASH_FILENAME='SHA256SUMS'
  readonly BITCOIN_HASH_FILE_SOURCE="${BITCOIN_SOURCE}/${BITCOIN_HASH_FILENAME}"
  readonly GPG_SIGNATURES_FILENAME='SHA256SUMS.asc'
  readonly GPG_SIGNATURES_FILE_SOURCE="${BITCOIN_SOURCE}/${GPG_SIGNATURES_FILENAME}"
  readonly GPG_GOOD_SIGNATURES_REQUIRED='7'
  readonly GUIX_SIGS_REPO='https://github.com/bitcoin-core/guix.sigs'
  readonly BITCOIN_TARBALL_TEMPORARY_PATH="${TEMP_DIRECTORY}/${BITCOIN_TARBALL_FILENAME}"
  readonly BITCOIN_HASH_FILE="${TEMP_DIRECTORY}/${BITCOIN_HASH_FILENAME}"
  readonly GPG_SIGNATURES_FILE="${TEMP_DIRECTORY}/${GPG_SIGNATURES_FILENAME}"
  readonly GUIX_SIGS_TEMPORARY_DIRECTORY="${TEMP_DIRECTORY}/guix.sigs"
  readonly GUIX_SIGS_DESTINATION_DIRECTORY="${HOME}/Downloads/guix.sigs"

  bitcoin_tarball_download
  bitcoin_tarball_validate
}

bitcoin_tarball_download_extract_test_install()
{
  readonly BITCOIN_CORE_EXTRACT_DIR="${TEMP_DIRECTORY}/bitcoin-core"
  readonly BITCOIN_INSTALL_BIN_SOURCE="${BITCOIN_CORE_EXTRACT_DIR}/bin"
  readonly BITCOIN_INSTALL_LIB_SOURCE="${BITCOIN_CORE_EXTRACT_DIR}/lib"
  readonly BITCOIN_INSTALL_INCLUDE_SOURCE="${BITCOIN_CORE_EXTRACT_DIR}/include"
  readonly BITCOIN_INSTALL_MAN_SOURCE="${BITCOIN_CORE_EXTRACT_DIR}/share/man/man1"
  readonly BITCOIN_INSTALL_DESTINATION='/usr/local'
  readonly BITCOIN_INSTALL_BIN_DESTINATION="${BITCOIN_INSTALL_DESTINATION}/bin"
  readonly BITCOIN_INSTALL_LIB_DESTINATION="${BITCOIN_INSTALL_DESTINATION}/lib"
  readonly BITCOIN_INSTALL_INCLUDE_DESTINATION="${BITCOIN_INSTALL_DESTINATION}/include"
  readonly BITCOIN_INSTALL_MAN_DESTINATION="${BITCOIN_INSTALL_DESTINATION}/share/man/man1"

  readonly BITCOIN_TARBALL_FILENAME="bitcoin-${target_bitcoin_version}-${TARGET_ARCHITECTURE}-${TARGET_BITCOIN_TARBALL_OS}.tar.gz"
  readonly BITCOIN_TARBALL_DESTINATION_PATH="${HOME}/Downloads/${BITCOIN_TARBALL_FILENAME}"

  [ -f "${BITCOIN_TARBALL_DESTINATION_PATH}" ] || bitcoin_tarball_download_validate
  bitcoin_tarball_extract
  bitcoin_tarball_test
  bitcoin_tarball_install

  log_info 'Removing installation files.'
  rm -r "${BITCOIN_CORE_EXTRACT_DIR:?}/"
  rm -r "${TEMP_DIRECTORY:?}/"
  log_info 'Bitcoin Core installation complete.'
}

bitcoin_tarball_extract()
{
  log_info 'Extracting Bitcoin Core.'
  [ -d "${BITCOIN_CORE_EXTRACT_DIR}"/ ] || mkdir "${BITCOIN_CORE_EXTRACT_DIR}"
  tar -xzf "${BITCOIN_TARBALL_DESTINATION_PATH}" -C "${BITCOIN_CORE_EXTRACT_DIR}"/ --strip-components=1
}

bitcoin_tarball_install()
{
  log_info "Installing Bitcoin Core ${target_bitcoin_version}."
  # install the libraries
  [ -d "${BITCOIN_INSTALL_LIB_DESTINATION}" ] ||
    mkdir -p "${BITCOIN_INSTALL_LIB_DESTINATION}" 2> /dev/null ||
    sudo mkdir "${BITCOIN_INSTALL_LIB_DESTINATION}" ||
    throw_error "Unable to create directory ${BITCOIN_INSTALL_LIB_DESTINATION}."
  case "${TARGET_KERNEL}" in
    Linux)
      sudo cp \
        "${BITCOIN_INSTALL_LIB_SOURCE}/libbitcoinconsensus.so.0.0.0" \
        "${BITCOIN_INSTALL_LIB_DESTINATION}/libbitcoinconsensus.so.0.0.0"
      (cd "${BITCOIN_INSTALL_LIB_DESTINATION}"/ && {
        sudo ln -s -f libbitcoinconsensus.so.0.0.0 libbitcoinconsensus.so.0 || {
          sudo rm -f libbitcoinconsensus.so.0
          sudo ln -s libbitcoinconsensus.so.0.0.0 libbitcoinconsensus.so.0
        }
      })
      (cd "${BITCOIN_INSTALL_LIB_DESTINATION}"/ && {
        sudo ln -s -f libbitcoinconsensus.so.0.0.0 libbitcoinconsensus.so || {
          sudo rm -f libbitcoinconsensus.so
          sudo ln -s libbitcoinconsensus.so.0.0.0 libbitcoinconsensus.so
        }
      })
      PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin:/sbin' \
        ldconfig -n "${BITCOIN_INSTALL_LIB_DESTINATION}"
      ;;
    Darwin)
      sudo cp \
        "${BITCOIN_INSTALL_LIB_SOURCE}/libbitcoinconsensus.0.dylib" \
        "${BITCOIN_INSTALL_LIB_DESTINATION}/libbitcoinconsensus.0.dylib"
      (cd "${BITCOIN_INSTALL_LIB_DESTINATION}"/ && {
        sudo ln -s -f libbitcoinconsensus.0.dylib libbitcoinconsensus.dylib || {
          sudo rm -f libbitcoinconsensus.dylib
          sudo ln -s libbitcoinconsensus.0.dylib libbitcoinconsensus.dylib
        }
      })
      sudo update_dyld_shared_cache
      ;;
    *)
      throw_error "UNSUPPORTED OS - unable to install Bitcoin Core."
      ;;
  esac

  # install the binaries
  [ -d "${BITCOIN_INSTALL_BIN_DESTINATION}" ] ||
    mkdir -p "${BITCOIN_INSTALL_BIN_DESTINATION}" 2> /dev/null ||
    sudo mkdir "${BITCOIN_INSTALL_BIN_DESTINATION}" ||
    throw_error "Unable to create directory ${BITCOIN_INSTALL_BIN_DESTINATION}."
  for bitcoin_executable in bitcoind bitcoin-qt bitcoin-cli bitcoin-tx bitcoin-util bitcoin-wallet; do
    [ "${TARGET_KERNEL}" = 'Darwin' ] && [ "${TARGET_ARCHITECTURE}" = 'arm64' ] &&
      codesign -s - "${BITCOIN_INSTALL_BIN_SOURCE}/${bitcoin_executable}"
    sudo install -c \
      "${BITCOIN_INSTALL_BIN_SOURCE}/${bitcoin_executable}" \
      "${BITCOIN_INSTALL_BIN_DESTINATION}/"
  done

  # install the header files
  [ -d "${BITCOIN_INSTALL_INCLUDE_DESTINATION}" ] ||
    mkdir -p "${BITCOIN_INSTALL_INCLUDE_DESTINATION}" 2> /dev/null ||
    sudo mkdir "${BITCOIN_INSTALL_INCLUDE_DESTINATION}" ||
    throw_error "Unable to create directory ${BITCOIN_INSTALL_INCLUDE_DESTINATION}."
  sudo install -c -m 644 \
    "${BITCOIN_INSTALL_INCLUDE_SOURCE}/bitcoinconsensus.h" \
    "${BITCOIN_INSTALL_INCLUDE_DESTINATION}/"

  # install the binary man pages
  [ -d "${BITCOIN_INSTALL_MAN_DESTINATION}" ] ||
    mkdir -p "${BITCOIN_INSTALL_MAN_DESTINATION}" 2> /dev/null ||
    sudo mkdir -p "${BITCOIN_INSTALL_MAN_DESTINATION}" ||
    throw_error "Unable to create directory ${BITCOIN_INSTALL_MAN_DESTINATION}."
  for man_page in bitcoind.1 bitcoin-qt.1 bitcoin-cli.1 bitcoin-tx.1 bitcoin-util.1 bitcoin-wallet.1; do
    sudo install -c -m 644 "${BITCOIN_INSTALL_MAN_SOURCE}/${man_page}" "${BITCOIN_INSTALL_MAN_DESTINATION}/"
  done
}

bitcoin_tarball_test()
{
  log_info 'Running the unit tests.'
  if [ "${TARGET_ARCHITECTURE}" = 'arm64' ]; then
    codesign -s - "${BITCOIN_INSTALL_BIN_SOURCE}"/test_bitcoin
  fi
  UNIT_TEST_RESPONSE="$("${BITCOIN_INSTALL_BIN_SOURCE}"/test_bitcoin 2>&1)" && readonly UNIT_TEST_RESPONSE
  case "${UNIT_TEST_RESPONSE}" in
    *'No errors detected'*) ;;
    *)
      printf '\n%s\n' "${UNIT_TEST_RESPONSE}"
      throw_error 'Unit tests failed.'
      ;;
  esac
}

bitcoin_tarball_validate()
{
  bitcoin_tarball_validate_checksum

  GPG_GOOD_SIGNATURE_COUNT="$(bitcoin_tarball_validate_count_signatures)" && readonly GPG_GOOD_SIGNATURE_COUNT
  if [ "${GPG_GOOD_SIGNATURE_COUNT}" -lt "${GPG_GOOD_SIGNATURES_REQUIRED}" ]; then
    throw_error "INVALID SIGNATURES. The download has failed. This script cannot continue due to security concerns. Please review the temporary file ${TEMP_DIRECTORY}/${GPG_SIGNATURES_FILE}."
  fi
  log_info "Found ${GPG_GOOD_SIGNATURE_COUNT} good signatures."

  [ -d "$(dirname "${BITCOIN_TARBALL_DESTINATION_PATH}")" ] || mkdir -p "$(dirname "${BITCOIN_TARBALL_DESTINATION_PATH}")"
  mv "${BITCOIN_TARBALL_TEMPORARY_PATH}" "${BITCOIN_TARBALL_DESTINATION_PATH}"
  [ -d "${GUIX_SIGS_DESTINATION_DIRECTORY}"/ ] || mv "${GUIX_SIGS_TEMPORARY_DIRECTORY}" "${GUIX_SIGS_DESTINATION_DIRECTORY}"
  [ -f "${BITCOIN_HASH_FILE}" ] && rm "${BITCOIN_HASH_FILE}"
  [ -f "${GPG_SIGNATURES_FILE}" ] && rm "${GPG_SIGNATURES_FILE}"
}

bitcoin_tarball_validate_checksum()
{
  cd "${TEMP_DIRECTORY}"/
  if command -v sha256sum > /dev/null; then
    SHA256_CHECK="$(grep "${BITCOIN_TARBALL_FILENAME}" "${BITCOIN_HASH_FILENAME}" | sha256sum --check 2> /dev/null)"
  elif command -v shasum > /dev/null; then
    SHA256_CHECK="$(grep "${BITCOIN_TARBALL_FILENAME}" "${BITCOIN_HASH_FILENAME}" | shasum -a 256 --check 2> /dev/null)"
  else
    throw_error "Either sha256sum or shasum must be installed. Please open an issue at ${NODEBUILDER_REPO}."
  fi
  readonly SHA256_CHECK
  cd - > /dev/null

  case "${SHA256_CHECK}" in
    *'OK'*) ;;
    *)
      throw_error "INVALID CHECKSUM. The download has failed. This script cannot continue due to security concerns. Please review the temporary file ${TEMP_DIRECTORY}/${BITCOIN_HASH_FILE}."
      ;;
  esac
  log_info 'Validated the checksum.'
}

bitcoin_tarball_validate_count_signatures()
{
  if [ -d "${GUIX_SIGS_DESTINATION_DIRECTORY}"/ ]; then
    gpg --quiet --import "${GUIX_SIGS_DESTINATION_DIRECTORY}"/builder-keys/*.gpg
  else
    # shellcheck disable=SC2015
    command -v torsocks > /dev/null 2>&1 && [ "${TARGET_KERNEL}" != 'Darwin' ] &&
      torsocks git clone --depth 1 --quiet "${GUIX_SIGS_REPO}.git" "${GUIX_SIGS_TEMPORARY_DIRECTORY}" ||
      git clone --depth 1 --quiet "${GUIX_SIGS_REPO}.git" "${GUIX_SIGS_TEMPORARY_DIRECTORY}"
    gpg --quiet --import "${GUIX_SIGS_TEMPORARY_DIRECTORY}"/builder-keys/*.gpg
  fi

  SIGNATURE_COUNT="$(gpg --verify "${GPG_SIGNATURES_FILE}" 2>&1 | grep -c '^gpg: Good signature from ')" &&
    readonly SIGNATURE_COUNT
  pgrep '^gpg-agent$' > /dev/null && gpgconf --kill gpg-agent
  pgrep '^keyboxd$' > /dev/null && gpgconf --kill keyboxd
  printf '%s\n' "${SIGNATURE_COUNT}"
}

ensure_curl_dependency()
{
  if command -v dnf > /dev/null 2>&1; then
    sudo dnf install --allowerasing --assumeyes curl > /dev/null
  elif ! command -v curl > /dev/null 2>&1; then
    log_info 'Ensuring curl depencency.'
    case "${TARGET_OPERATING_SYSTEM}" in
      alpine)
        sudo apk --quiet add curl
        ;;
      debian | ubuntu)
        sudo apt-get install -y curl > /dev/null
        ;;
      fedora* | rhel | centos* | rocky | ol)
        sudo dnf install --allowerasing --assumeyes curl > /dev/null
        ;;
      gentoo)
        emerge --jobs "${SYS_CORES_COUNT}" --load-average "${SYS_CORES_PLUS_ONE}" --quiet --quiet-build --quiet-fail net-misc/curl
        ;;
      arch | endeavouros | garuda | manjaro)
        sudo pacman -Syu --needed --noconfirm curl > /dev/null
        ;;
      suse | sles | *opensuse*)
        sudo zypper --non-interactive --quiet install curl > /dev/null
        ;;
      clear-linux-os)
        sudo swupd bundle-add curl > /dev/null
        ;;
      Darwin)
        throw_error "Please install the 'curl' dependency."
        ;;
      FreeBSD)
        sudo pkg install -y curl > /dev/null
        ;;
      OpenBSD)
        sudo pkg_add curl > /dev/null
        ;;
      *)
        if command -v apk > /dev/null; then
          sudo apk --quiet add curl
        elif command -v apt-get > /dev/null; then
          sudo apt-get -qq install -y curl > /dev/null
        elif command -v dnf > /dev/null; then
          sudo dnf install --allowerasing --assumeyes curl > /dev/null
        elif command -v pacman > /dev/null; then
          sudo pacman -Syu --needed --noconfirm curl > /dev/null
        elif command -v zypper > /dev/null; then
          sudo zypper --non-interactive --quiet install curl > /dev/null
        else
          throw_error "Package manager was not found. Please report an issue at ${NODEBUILDER_REPO}."
        fi
        ;;
    esac
  fi
  command -v curl > /dev/null 2>&1 || throw_error "Unable to install 'curl'. Please report this error at ${NODEBUILDER_REPO}."
}

ensure_sudo_dependency()
{
  if ! command -v sudo > /dev/null 2>&1; then
    log_info 'Ensuring sudo depencency.'
    case "${TARGET_OPERATING_SYSTEM}" in
      alpine)
        apk --quiet add sudo
        ;;
      debian | ubuntu)
        apt-get install -y sudo > /dev/null
        ;;
      fedora* | rhel | centos* | rocky | ol)
        dnf install --allowerasing --assumeyes sudo > /dev/null
        ;;
      gentoo)
        emerge --sync --quiet
        emerge --jobs "${SYS_CORES_COUNT}" --load-average "${SYS_CORES_PLUS_ONE}" --quiet --quiet-build --quiet-fail app-admin/sudo
        ;;
      arch | endeavouros | garuda | manjaro)
        pacman -Syu --needed --noconfirm sudo > /dev/null
        ;;
      suse | sles | *opensuse*)
        zypper --non-interactive --quiet install sudo > /dev/null
        ;;
      clear-linux-os)
        swupd bundle-add sudo > /dev/null
        ;;
      FreeBSD)
        pkg install -y sudo > /dev/null
        ;;
      OpenBSD)
        pkg_add sudo-- > /dev/null
        ;;
      *)
        if command -v apk > /dev/null; then
          apk --quiet add sudo
        elif command -v apt-get > /dev/null; then
          apt-get -qq install -y sudo > /dev/null
        elif command -v dnf > /dev/null; then
          dnf install sudo > /dev/null
        elif command -v pacman > /dev/null; then
          pacman -Syu --needed --noconfirm sudo > /dev/null
        elif command -v zypper > /dev/null; then
          zypper --non-interactive --quiet install sudo > /dev/null
        else
          throw_error "Package manager was not found. Please report an issue at ${NODEBUILDER_REPO}."
        fi
        ;;
    esac
  fi
  command -v sudo > /dev/null 2>&1 || throw_error "Unable to install 'sudo'. Please report this error at ${NODEBUILDER_REPO}."
}

ensure_xargs_dependency()
{
  if ! command -v xargs > /dev/null 2>&1; then
    log_info 'Ensuring xargs depencency.'
    case "${TARGET_OPERATING_SYSTEM}" in
      alpine)
        sudo apk --quiet add findutils
        ;;
      debian | ubuntu)
        apt-get install -y findutils > /dev/null
        ;;
      fedora* | rhel | centos* | rocky | ol)
        dnf install --allowerasing --assumeyes findutils > /dev/null
        ;;
      gentoo)
        emerge --sync --quiet
        emerge --jobs "${SYS_CORES_COUNT}" --load-average "${SYS_CORES_PLUS_ONE}" --quiet --quiet-build --quiet-fail sys-apps/findutils
        ;;
      arch | endeavouros | garuda | manjaro)
        pacman -Syu --needed --noconfirm findutils > /dev/null
        ;;
      suse | sles | *opensuse*)
        zypper --non-interactive --quiet install findutils > /dev/null
        ;;
      clear-linux-os)
        swupd bundle-add findutils > /dev/null
        ;;
      FreeBSD)
        sudo pkg install -y findutils > /dev/null
        ;;
      OpenBSD)
        sudo pkg_add findutils > /dev/null
        ;;
      *)
        if command -v apk > /dev/null; then
          sudo apk --quiet add findutils
        elif command -v apt-get > /dev/null; then
          apt-get -qq install -y findutils > /dev/null
        elif command -v dnf > /dev/null; then
          dnf install findutils > /dev/null
        elif command -v pacman > /dev/null; then
          pacman -Syu --needed --noconfirm findutils > /dev/null
        elif command -v zypper > /dev/null; then
          zypper --non-interactive --quiet install findutils > /dev/null
        else
          [ -f /etc/os-release ] && cat /etc/os-release
          [ -f /etc/lsb-release ] && cat /etc/lsb-release
          throw_error "Package manager was not found. Please report an issue at ${NODEBUILDER_REPO}."
        fi
        ;;
    esac
    command -v xargs > /dev/null 2>&1 ||
      throw_error "Unable to install 'xargs'. Report this error at ${NODEBUILDER_REPO}."
  fi
}

get_free_space_in_mib()
{
  case "${TARGET_KERNEL}" in
    Darwin | FreeBSD)
      /bin/df -m "${BITCOIN_DATA_DIRECTORY}" | awk 'NR==2 {print $4}'
      ;;
    OpenBSD)
      BLOCKSIZE=1M df "${BITCOIN_DATA_DIRECTORY}" | awk 'NR==2 {print $4}'
      ;;
    *)
      df --output=avail --block-size='1MiB' "${BITCOIN_DATA_DIRECTORY}" | sed 1d
      ;;
  esac
}

get_log_timestamp()
{
  date +'%Y-%m-%dT%H:%M:%S'
}

get_memory_metric_in_mib()
{
  metric_to_query="$1"
  awk -v metric="${metric_to_query}" \
    -v kib_mib_factor="${KIB_TO_MIB}" \
    '$0 ~ metric { printf "%d \n", $2 / kib_mib_factor }' /proc/meminfo
}

get_operating_system()
{
  case "${TARGET_KERNEL}" in
    Darwin | FreeBSD | OpenBSD)
      printf '%s\n' "${TARGET_KERNEL}"
      ;;
    *)
      OS_RELEASE_ID="$(grep '^ID=' /etc/os-release | cut -d= -f2)" && readonly OS_RELEASE_ID
      OS_RELEASE_ID_LIKE="$(grep '^ID_LIKE=' /etc/os-release | cut -d= -f2)" && readonly OS_RELEASE_ID_LIKE
      if [ -n "${OS_RELEASE_ID}" ] || [ -n "${OS_RELEASE_ID_LIKE}" ]; then
        printf '%s\n' "${OS_RELEASE_ID_LIKE:-${OS_RELEASE_ID}}"
      else
        throw_error 'Failed to determine OS release type'
      fi
      ;;
  esac
}

# shellcheck disable=SC2317
handle_exit()
{
  [ -n "${TEMP_DIRECTORY:-}" ] && rm -rf -- "${TEMP_DIRECTORY:?}"/
}

# shellcheck disable=SC2317
handle_sigint()
{
  log_warning 'Detected Ctrl+C. Exiting.'
  handle_exit
  exit 0
}

install_build_dependencies()
{
  case "${TARGET_OPERATING_SYSTEM}" in
    alpine)
      install_build_dependencies_apk
      ;;
    debian | ubuntu)
      install_build_dependencies_aptget
      ;;
    fedora* | rhel | centos* | rocky | ol)
      install_build_dependencies_dnf
      ;;
    gentoo)
      install_build_dependencies_emerge
      ;;
    arch | endeavouros | garuda | manjaro)
      install_build_dependencies_pacman
      ;;
    suse | sles | *opensuse*)
      install_build_dependencies_zypper
      ;;
    clear-linux-os)
      install_build_dependencies_swupd
      ;;
    Darwin)
      install_build_dependencies_darwin
      ;;
    FreeBSD)
      install_build_dependencies_freebsd
      ;;
    OpenBSD)
      install_build_dependencies_openbsd
      ;;
    *)
      install_build_command_function=''
      for package_manager in \
        apk \
        apt-get \
        dnf \
        emerge \
        pacman \
        swupd \
        zypper; do
        if command -v "${package_manager}" > /dev/null; then
          install_build_command_function="install_build_dependencies_$(echo "${package_manager}" | tr -d '-')"
          break
        fi
      done
      if [ -n "${install_build_command_function}" ]; then
        "${install_build_command_function}"
      else
        log_warning 'Unable to determine build dependencies. Attempting to compile but might see errors.'
      fi
      ;;
  esac
}

install_build_dependencies_apk()
{
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_apk.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."
  printf '%s\n' "${dependencies}" | xargs apk --quiet add |
    grep -v 'ICU with non-English locales' -A2 -B1 || true
}

install_build_dependencies_aptget()
{
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_aptget.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."
  printf '%s\n' "${dependencies}" | xargs sudo DEBIAN_FRONTEND=noninteractive apt-get -qq install --assume-yes --no-install-recommends > /dev/null 2>&1
  # TODO: Remove gcc-12 installation on next line when Ubuntu updates the default version of gcc to support C++ 20 features. Bitcoin Core requires gcc with support for C++ 20 features.
  DEBIAN_FRONTEND=noninteractive sudo apt-get -qq install --assume-yes --no-install-recommends gcc-12
}

install_build_dependencies_darwin()
{
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_darwin.txt"
  #TODO: wrap this command with torsocks-curl with curl fallback
  sudo printf '' && NONINTERACTIVE=1 /bin/bash -c "$(curl --fail --silent --show-error --location --retry 5 \
    https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" > /dev/null 2>&1
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."
  printf '%s\n' "${dependencies}" | xargs brew install --quiet > /dev/null
}

install_build_dependencies_dnf()
{
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_dnf.txt"
  OS_MAJOR_VERSION_ID="$(grep "^VERSION_ID=" /etc/os-release | cut -d= -f2 | tr -d '"' | cut -d. -f1)" && readonly OS_MAJOR_VERSION_ID

  case "$(grep "^ID=" /etc/os-release | cut -d= -f2 | tr -d '"')" in
    amzn)
      throw_error "Building from source on Amazon Linux is unsupported."
      ;;
    rhel)
      sudo subscription-manager identity > /dev/null 2>&1 ||
        throw_error "Register your RHEL subscription with 'sudo subscription-manager subscribe'."
      sudo dnf config-manager --enable "rhel-${OS_MAJOR_VERSION_ID}-for-${TARGET_ARCHITECTURE}-appstream-rpms" ||
        throw_error "Failed to enable EPEL release rhel-${OS_MAJOR_VERSION_ID}-for-${TARGET_ARCHITECTURE}-appstream-rpms."
      ;;
    *) ;;
  esac

  dnf list installed epel-release > /dev/null 2>&1 ||
    sudo dnf --assumeyes install "https://dl.fedoraproject.org/pub/epel/epel-release-latest-${OS_MAJOR_VERSION_ID}.noarch.rpm"

  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."

  printf '%s\n' "${dependencies}" | xargs sudo dnf install --assumeyes > /dev/null
}

install_build_dependencies_emerge()
{
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_emerge.txt"
  printf '\n'
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error 'The list of dependencies is empty.'
  if ! printf '%s\n' "${dependencies}" | xargs emerge --autounmask-write \
    --jobs "${SYS_CORES_COUNT}" --load-average "${SYS_CORES_PLUS_ONE}" --quiet --quiet-build --quiet-fail; then
    etc-update --automode -5
    emerge --update --jobs "${SYS_CORES_COUNT}" --load-average "${SYS_CORES_PLUS_ONE}" --quiet --quiet-build --quiet-fail --deep --newuse @world
    # Run the install command again
    printf '%s\n' "${dependencies}" | xargs emerge --autounmask-write \
      --jobs "${SYS_CORES_COUNT}" --load-average "${SYS_CORES_PLUS_ONE}" --quiet --quiet-build --quiet-fail
  fi
}

install_build_dependencies_freebsd()
{
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_freebsd.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."
  printf '%s\n' "${dependencies}" | xargs sudo pkg install --yes > /dev/null
}

install_build_dependencies_openbsd()
{
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_openbsd.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."
  for package in ${dependencies}; do
    if [ "${package}" = 'sqlite3' ]; then
      sudo pkg_add "${package}" > /dev/null
    else
      package_latest_version="$(pkg_info -Q "${package}" | grep "^${package}\-" | grep -v "${package}\-[A-Za-z0-9]*\-" | sort -V | tail -1)"
      [ "${package}" = 'autoconf' ] && autoconf_package_latest_version="${package_latest_version}"
      [ "${package}" = 'automake' ] && automake_package_latest_version="${package_latest_version}"
      if [ -z "${package_latest_version}" ]; then
        throw_error "Package '${package}' was not found in pkg_info."
      elif [ "$(echo "${package_latest_version}" | cut -d' ' -f2)" != '(installed)' ]; then
        sudo pkg_add "${package_latest_version}" > /dev/null
      fi
    fi
  done

  # major-minor version only
  AUTOCONF_VERSION="$(echo "${autoconf_package_latest_version}" | cut -d' ' -f1 | cut -d- -f2 | cut -d. -f1,2)" &&
    export AUTOCONF_VERSION
  AUTOMAKE_VERSION="$(echo "${automake_package_latest_version}" | cut -d' ' -f1 | cut -d- -f2 | cut -d. -f1,2)" &&
    export AUTOMAKE_VERSION
}

install_build_dependencies_pacman()
{
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_pacman.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."
  printf '%s\n' "${dependencies}" | xargs sudo pacman -Syu --needed --noconfirm --quiet > /dev/null 2> "${STDERR_COMPILE_LOG_FILE}"
  grep -v 'skipping' "${STDERR_COMPILE_LOG_FILE}" >&2 || true
}

install_build_dependencies_swupd()
{
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_swupd.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."
  printf '%s\n' "${dependencies}" | xargs sudo swupd bundle-add --quiet > /dev/null
}

install_build_dependencies_zypper()
{
  readonly BUILD_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/build_dependencies_zypper.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${BUILD_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${BUILD_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error "The list of dependencies is empty."
  printf '%s\n' "${dependencies}" | xargs sudo zypper --non-interactive --quiet install
  export CXX=g++-13
}

install_runtime_dependencies()
{
  log_info 'Ensuring base dependencies.'
  case "${TARGET_OPERATING_SYSTEM}" in
    alpine)
      install_runtime_dependencies_apk
      ;;
    debian | ubuntu)
      install_runtime_dependencies_aptget
      ;;
    fedora* | rhel | centos* | rocky | ol)
      install_runtime_dependencies_dnf
      ;;
    gentoo)
      install_runtime_dependencies_emerge
      ;;
    arch | endeavouros | garuda | manjaro)
      install_runtime_dependencies_pacman
      ;;
    suse | sles | *opensuse*)
      install_runtime_dependencies_zypper
      ;;
    clear-linux-os)
      install_runtime_dependencies_swupd
      ;;
    Darwin)
      install_runtime_dependencies_darwin
      ;;
    FreeBSD)
      install_runtime_dependencies_freebsd
      ;;
    OpenBSD)
      install_runtime_dependencies_openbsd
      ;;
    *)
      install_runtime_command_function=''
      for package_manager in \
        apk \
        apt-get \
        dnf \
        emerge \
        pacman \
        swupd \
        zypper; do
        if command -v "${package_manager}" > /dev/null; then
          install_runtime_command_function="install_runtime_dependencies_$(echo "${package_manager}" | tr -d '-')"
          break
        fi
      done

      if [ -n "${install_runtime_command_function}" ]; then
        "${install_runtime_command_function}"
      else
        throw_error 'Unknown package manager. This version of Linux is not supported.'
      fi
      ;;
  esac
}

install_runtime_dependencies_apk()
{
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_apk.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs sudo apk --quiet add
}

install_runtime_dependencies_aptget()
{
  check_dpkg_lock
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_aptget.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs sudo DEBIAN_FRONTEND=noninteractive apt-get -qq install --assume-yes --no-install-recommends > /dev/null 2>&1
}

install_runtime_dependencies_darwin()
{
  if ! command -v git > /dev/null 2>&1; then
    log_info 'Ensuring git dependency via the Xcode Command Line Tools.'
    # These steps were taken from: https github com/Homebrew/install/blob/aceed88a4a062e2b41dc40a7428c71309fce14c9/install.sh#L831
    # TODO: find a way to install only the git binary, not all the Xcode tools. Unattended git installation shouldn't take 20+ lines of code.
    CLT_INSTALL_IN_PROGRESS='/tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress' && readonly CLT_INSTALL_IN_PROGRESS
    sudo touch "${CLT_INSTALL_IN_PROGRESS}"
    CLT_LABEL_COMMAND="/usr/sbin/softwareupdate -l | grep -B 1 -E 'Command Line Tools' | awk -F'*' '/^ *\\*/ {print \$2}' | \
      sed -e 's/^ *Label: //' -e 's/^ *//' | sort -V | tail -n1 | tr -d '\n'" && readonly CLT_LABEL_COMMAND
    CLT_LABEL="$(/bin/sh -c "${CLT_LABEL_COMMAND}")" && readonly CLT_LABEL
    if [ -n "${CLT_LABEL}" ]; then
      sudo /usr/sbin/softwareupdate -i "${CLT_LABEL}" > /dev/null
    else
      throw_error 'Failed to install git. Cannot find a compatible Xcode Command Line Tools package.'
    fi
    sudo rm "${CLT_INSTALL_IN_PROGRESS}"

    if command -v git > /dev/null 2>&1; then
      :
    elif [ "${unattended}" = 'true' ]; then
      throw_error 'Failed to install Xcode Command Line Tools. Try re-running without -u/--unattended or manually installing git.'
    else
      printf '%s\n%s\n' 'failed.' 'Installing the Command Line Tools (expect a popup window).'
      /usr/bin/xcode-select --install
      printf '%s\n' "PRESS ENTER after you've completed the installation via the popup window."
      read -r _
      if ! command -v git > /dev/null 2>&1; then
        throw_error 'Failed to install git via the Xcode Command Line Tools. Try manually installing git'
      fi
    fi
  fi
}

install_runtime_dependencies_dnf()
{
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_dnf.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs sudo dnf --assumeyes --quiet install > /dev/null
}

install_runtime_dependencies_emerge()
{
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_emerge.txt"
  printf '\n'
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs emerge --autounmask-write --jobs "${SYS_CORES_COUNT}" --load-average "${SYS_CORES_PLUS_ONE}" --quiet --quiet-build --quiet-fail
}

install_runtime_dependencies_freebsd()
{
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_freebsd.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs sudo pkg install --yes > /dev/null
}

install_runtime_dependencies_openbsd()
{
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_openbsd.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs sudo pkg_add > /dev/null
}

install_runtime_dependencies_pacman()
{
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_pacman.txt"
  readonly STDERR_DEPENDENCIES_LOG_FILE="${TEMP_DIRECTORY}/stderr_runtime_dependencies_log"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs sudo pacman -Syu --needed --noconfirm --quiet > /dev/null 2> "${STDERR_DEPENDENCIES_LOG_FILE}"
  grep -v 'skipping' "${STDERR_DEPENDENCIES_LOG_FILE}" >&2 || true
  rm "${STDERR_DEPENDENCIES_LOG_FILE}"
}

install_runtime_dependencies_swupd()
{
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_swupd.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs sudo swupd bundle-add --quiet > /dev/null
}

install_runtime_dependencies_zypper()
{
  readonly RUNTIME_DEPENDENCIES_URL="${DEPENDENCIES_BASE_URL}/runtime_dependencies_zypper.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${RUNTIME_DEPENDENCIES_URL}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${RUNTIME_DEPENDENCIES_URL}")
  [ -z "${dependencies:-}" ] && throw_error 'The list of dependencies is empty.'
  printf '%s\n' "${dependencies}" | xargs sudo zypper --non-interactive --quiet install > /dev/null
}

install_system_updates()
{
  log_info 'Performing a system upgrade.'
  case "${TARGET_OPERATING_SYSTEM}" in
    alpine)
      install_system_updates_apk
      ;;
    debian | ubuntu)
      install_system_updates_aptget
      ;;
    fedora* | rhel | centos* | rocky | ol)
      install_system_updates_dnf
      ;;
    gentoo)
      install_system_updates_emerge
      ;;
    arch | endeavouros | garuda | manjaro)
      install_system_updates_pacman
      ;;
    suse | sles | *opensuse*)
      install_system_updates_zypper
      ;;
    clear-linux-os)
      install_system_updates_swupd
      ;;
    FreeBSD)
      install_system_updates_freebsd
      ;;
    OpenBSD)
      install_system_updates_openbsd
      ;;
    *)
      if command -v apk > /dev/null; then
        install_system_updates_apk
      elif command -v apt-get > /dev/null; then
        install_system_updates_aptget
      elif command -v dnf > /dev/null; then
        install_system_updates_dnf
      elif command -v emerge > /dev/null; then
        install_system_updates_emerge
      elif command -v pacman > /dev/null; then
        install_system_updates_pacman
      elif command -v swupd > /dev/null; then
        install_system_updates_swupd
      elif command -v zypper > /dev/null; then
        install_system_updates_zypper
      else
        throw_error 'This version of Linux is not supported.'
      fi
      ;;
  esac

  if [ "${skip_reboot_on_system_update:-false}" = 'true' ]; then
    :
  elif [ ! -f /var/run/reboot-required ]; then
    :
  elif is_running_in_container; then
    throw_error "The Docker base image is outdated. Please open an issue at ${NODEBUILDER_REPO}."
  elif is_running_in_ci; then
    log_info 'Skipping required reboot in CI/CD environment.'
  else
    printf '\n%s\n%s\n' 'REBOOT IS REQUIRED to upgrade the following packages:' "$(cat /var/run/reboot-required.pkgs)"
    if [ "${unattended}" = 'false' ]; then
      log_info 'PRESS ENTER to reboot or press Ctrl+C to exit.'
      read -r _
    fi
    log_warning 'Rebooting.'
    sudo reboot
    exit 0
  fi
}

install_system_updates_apk()
{
  sudo apk update --quiet
  sudo apk upgrade --quiet
}

install_system_updates_aptget()
{
  check_dpkg_lock
  readonly STDERR_INSTALL_LOG_FILE="${TEMP_DIRECTORY}/stderr_install.log"
  sudo apt-get -qq update && sudo NEEDRESTART_MODE=a apt-get -qq dist-upgrade --assume-yes > /dev/null 2> "${STDERR_INSTALL_LOG_FILE}"
  grep -v 'apt-utils' "${STDERR_INSTALL_LOG_FILE}" >&2 || true
  rm "${STDERR_INSTALL_LOG_FILE}"
}

install_system_updates_dnf()
{
  sudo dnf clean all && sudo dnf --assumeyes --quiet upgrade > /dev/null
}

install_system_updates_emerge()
{
  readonly GENTOO_EBUILD_REPOSITORY='/var/db/repos/gentoo'
  readonly EMERGE_UPDATE_COMMAND="emerge --update --jobs ${SYS_CORES_COUNT} --load-average ${SYS_CORES_PLUS_ONE} --quiet --quiet-build --quiet-fail --deep --newuse @world"
  readonly EMERGE_MAX_RETRIES='3'
  printf '\n'

  [ -d "${GENTOO_EBUILD_REPOSITORY}" ] || mkdir -p "${GENTOO_EBUILD_REPOSITORY}"

  emerge --depclean --quiet || throw_error "Failed to clean up obsolete packages"

  emerge_retry_index='0'
  while [ "${emerge_retry_index}" -lt "${EMERGE_MAX_RETRIES}" ]; do
    if eval "${EMERGE_UPDATE_COMMAND}"; then
      break
    else
      emerge_retry_index=$((emerge_retry_index + 1))
      sleep 5
    fi
  done

  [ "${emerge_retry_index}" -ge "${EMERGE_MAX_RETRIES}" ] &&
    throw_error "Emerge system update failed after ${EMERGE_MAX_RETRIES} attempts"

  emerge --depclean --quiet || throw_error "Failed to clean up obsolete packages"
}

install_system_updates_freebsd()
{
  sudo pkg update > /dev/null
  sudo pkg upgrade --yes > /dev/null
}

install_system_updates_openbsd()
{
  sudo pkg_add -uu > /dev/null
}

install_system_updates_pacman()
{
  sudo pacman -Syu --noconfirm --quiet > /dev/null
}

install_system_updates_swupd()
{
  sudo swupd update --quiet > /dev/null
}

install_system_updates_zypper()
{
  sudo zypper --non-interactive --quiet dist-upgrade > /dev/null
}

is_running_as_root()
{
  if [ "$(id -u)" -eq 0 ]; then
    return 0
  else
    return 1
  fi
}

is_running_in_ci()
{
  if [ "${CI:-false}" = 'true' ]; then
    return 0
  else
    return 1 #1=false
  fi
}

is_running_in_container()
{
  if [ -f /proc/1/cgroup ] && grep -q 'docker\|lxc\|actions_job' /proc/1/cgroup; then
    return 0
  elif [ -f /proc/1/mountinfo ] && grep -q 'docker\|lxc\|actions_job' /proc/1/mountinfo; then
    return 0
  else
    return 1
  fi
}

is_valid_bitcoin_version()
{
  [ -z "$1" ] && throw_error 'No arguemnt passed into is_valid_bitcoin_version().'
  bitcoin_version_to_check="$1"
  for version in ${VALID_BITCOIN_VERSION_LIST}; do
    if [ "${bitcoin_version_to_check}" = "${version}" ]; then
      return 0
    fi
  done
  return 1
}

log_error()
{
  printf "[%s] ERROR: ${CONSOLE_COLOR_RED:-}%s" "$(get_log_timestamp)" "$*" \
    >&2
  reset_console_color
  printf '\n' >&2
}

log_info()
{
  printf '[%s]  INFO: %s\n' "$(get_log_timestamp)" "$*"
}

log_success()
{
  printf "[%s]  DONE: ${CONSOLE_COLOR_GREEN:-}%s" "$(get_log_timestamp)" "$*"
  reset_console_color
  printf '\n'
}

log_warning()
{
  printf "[%s]  WARN: ${CONSOLE_COLOR_YELLOW:-}%s" "$(get_log_timestamp)" "$*"
  reset_console_color
  printf '\n'
}

print_usage()
{
  printf '%s\n\n' "Usage: $0 [options]"
  printf '%s\n' 'Options:'
  printf '%s\n' '-b, --bitcoin-version   Specify the Bitcoin version'
  printf '%s\n' '-c, --compile           Build Bitcoin from source'
  printf '%s\n' '-h, --help              Display this help message'
  printf '%s\n' '-r, --skip-reboot       Skip reboot on system updates'
  printf '%s\n' '-p, --prune             Set a prune value in MiB'
  printf '%s\n' '-t, --test              Run unit tests on functions'
  printf '%s\n' '-u, --unattended        Run in non-interactive mode'
  printf '%s\n' '-V, --version           Print the nodebuilder version'
}

print_version()
{
  printf '%s\n' 'nodebuilder 1.9.1'
  printf '%s\n' 'Copyright (C) 2024 bitcoin-tools/nodebuilder developers'
  printf '%s\n' 'License: MIT-0. Details at: https://opensource.org/licenses/MIT'
  printf '%s\n' 'For support, visit: https://github.com/bitcoin-tools/nodebuilder'
}

reset_console_color()
{
  # shellcheck disable=SC2059
  printf "${CONSOLE_COLOR_NORMAL:-}"
}

run_unit_tests()
{
  log_info 'TODO: Run unit tests on functions.'
  return 0
}

set_bitcoin_core_option()
{
  option="$1"
  value="$2"
  if [ -f "${BITCOIN_CORE_CONFIG_FILE:?}" ]; then
    sed -i.bak "/^${option}=/d" "${BITCOIN_CORE_CONFIG_FILE:?}"
    rm "${BITCOIN_CORE_CONFIG_FILE:?}.bak"
  else
    install -m 600 /dev/null "${BITCOIN_CORE_CONFIG_FILE:?}"
  fi
  printf '%s\n' "${option}=${value}" >> "${BITCOIN_CORE_CONFIG_FILE:?}"
}

# This function sets a Bitcoin Core option in the configuration file if it's not already set.
set_if_unset_bitcoin_core_option()
{
  option="$1"
  value="$2"
  # create a blank config file if it doesn't exist
  if [ ! -f "${BITCOIN_CORE_CONFIG_FILE:?}" ]; then
    install -m 600 /dev/null "${BITCOIN_CORE_CONFIG_FILE:?}"
  fi
  # add the new option if not already set
  grep -q -i "^${option}=" "${BITCOIN_CORE_CONFIG_FILE:?}" ||
    printf '%s\n' "${option}=${value}" >> "${BITCOIN_CORE_CONFIG_FILE:?}"
}

throw_error()
{
  if [ $# -eq 1 ]; then
    log_error "$1"
  elif [ $# -gt 1 ]; then
    log_error "$@"
  else
    log_error 'Unknown error thrown.'
  fi
  handle_exit
  exit 1
}

CONSOLE_COLOR_RED=''
CONSOLE_COLOR_GREEN=''
CONSOLE_COLOR_YELLOW=''
CONSOLE_COLOR_NORMAL=''
if command -v tput > /dev/null 2>&1 && [ "$(tput colors 2> /dev/null)" -ge 8 ]; then
  CONSOLE_COLOR_RED="$(tput setaf 1)"
  CONSOLE_COLOR_GREEN="$(tput setaf 2)"
  CONSOLE_COLOR_YELLOW="$(tput setaf 3)"
  CONSOLE_COLOR_NORMAL="$(tput sgr0)"
else
  case "${TERM:-}" in
    '' | xterm* | screen* | tmux* | linux | gnome-terminal | konsole | rxvt* | \
      putty | mintty | alacritty | st | su | vt220)
      CONSOLE_COLOR_RED='\033[31m'
      CONSOLE_COLOR_GREEN='\033[32m'
      CONSOLE_COLOR_YELLOW='\033[33m'
      CONSOLE_COLOR_NORMAL='\033[0m'
      ;;
    *)
      log_warning "TERM variable '${TERM}' is not recognized. Disabling color."
      ;;
  esac
fi
readonly CONSOLE_COLOR_RED
readonly CONSOLE_COLOR_GREEN
readonly CONSOLE_COLOR_YELLOW
readonly CONSOLE_COLOR_NORMAL

# This list excludes vulnerable versions, e.g. CVE-2015-6031 and CVE-2018-17144
readonly VALID_BITCOIN_VERSION_LIST='0.9.5 0.10.0 0.10.1 0.10.2 0.10.3 0.10.4 \
    0.11.0 0.11.1 0.11.2 0.12.0 0.12.1 0.13.0 0.13.1 0.13.2 \0.14.3 0.15.2 \
    0.16.3 0.17.0 0.17.0.1 0.17.1 0.17.2 0.18.0 0.18.1 0.19.0 0.19.0.1 0.19.1 \
    0.20.0 0.20.1 0.20.2 0.21.0 0.21.1 0.21.2 22.0 22.1 23.0 23.1 23.2 24.0 \
    24.0.1 24.1 24.2 25.0 25.1 25.2 26.0 26.1 26.2 27.0 27.1'

target_bitcoin_version='27.1'

compile_bitcoin_flag='false'
prune_value='-1'
skip_reboot_on_system_update='false'
unattended='false'
unit_tests='false'

while [ $# -gt 0 ]; do
  case "$1" in
    -b | --bitcoin-version)
      if [ $# -eq 1 ]; then
        throw_error '-b/--bitcoin-version requires an argument.'
      fi
      if is_valid_bitcoin_version "$2"; then
        target_bitcoin_version="$2"
      else
        throw_error "The Bitcoin version '$2' is not valid. Please use a value such as '27.0' from https://bitcoincore.org/bin/."
      fi
      shift
      ;;
    -c | --compile)
      compile_bitcoin_flag='true'
      ;;
    -h | --help)
      print_usage
      exit 0
      ;;
    -p | --prune)
      if [ $# -eq 1 ]; then
        throw_error '-p/--prune requires an argument'
      fi
      case $2 in
        *[!0-9]*) # if $2 contains any non-numeric characters
          throw_error "The prune value '$2' must be a positive integer or zero to disable pruning"
          ;;
        *) ;;
      esac
      if [ "$2" -gt 0 ] && [ "$2" -lt 550 ]; then
        throw_error "The prune value '$2' must be at least 550 (MiB) or zero to disable pruning"
      fi
      prune_value="$2"
      shift
      ;;
    -r | --skip-reboot)
      skip_reboot_on_system_update='true'
      ;;
    -t | --test)
      unit_tests='true'
      ;;
    -u | --unattended)
      unattended='true'
      ;;
    -V | --version)
      print_version
      ;;
    *)
      printf '%s\n%s\n' "Error: '$1' is invalid." 'Use -h or --help for available options.'
      exit 1
      ;;
  esac
  shift
done

[ "${unit_tests}" = 'true' ] && run_unit_tests

trap 'if [ $? -eq 0 ]; then handle_exit; else throw_error "Unhandled error at line ${LINENO:-}."; fi' EXIT
trap handle_sigint INT

readonly BYTES_TO_KIB=1024
readonly KIB_TO_MIB="${BYTES_TO_KIB}"
readonly MIB_TO_GIB="${BYTES_TO_KIB}"

TEMP_DIRECTORY="$(mktemp -d)" && readonly TEMP_DIRECTORY
TARGET_ARCHITECTURE="$(uname -m)" && readonly TARGET_ARCHITECTURE
TARGET_KERNEL="$(uname -s)" && readonly TARGET_KERNEL
TARGET_OPERATING_SYSTEM="$(get_operating_system)" && readonly TARGET_OPERATING_SYSTEM

readonly BITCOIN_CORE_REPO='https://github.com/bitcoin/bitcoin'
readonly NODEBUILDER_REPO='https://github.com/bitcoin-tools/nodebuilder'
readonly NODEBUILDER_DEPENDENCIES_TAG='v1.9.1'
readonly DEPENDENCIES_BASE_URL="${NODEBUILDER_REPO}/raw/${NODEBUILDER_DEPENDENCIES_TAG}/resources/dependencies"

case "${TARGET_KERNEL}" in
  Linux | FreeBSD)
    SYS_CORES_COUNT="$(nproc)"
    ;;
  Darwin)
    SYS_CORES_COUNT="$(sysctl -n hw.physicalcpu)"
    ;;
  OpenBSD)
    SYS_CORES_COUNT="$(sysctl -n hw.ncpu)"
    ;;
  MINGW* | Cygwin)
    throw_error 'Windows is not supported. Use Linux, macOS, or Windows Subsystem for Linux instead.'
    ;;
  *)
    throw_error "${TARGET_KERNEL} is not supported. Please run on Linux or macOS."
    ;;
esac
readonly SYS_CORES_COUNT
readonly SYS_CORES_PLUS_ONE="$((SYS_CORES_COUNT + 1))"

ensure_sudo_dependency
ensure_xargs_dependency

if is_running_in_ci ||
  is_running_in_container ||
  sudo --validate --noninteractive > /dev/null 2>&1; then
  :
else
  printf '%s\n' 'Please enter your password to log in, if requested.'
  sudo --validate
fi

clear_the_terminal
case "${TARGET_KERNEL}" in
  Linux | FreeBSD | OpenBSD)
    log_info "Detected: running ${TARGET_KERNEL}."
    TARGET_BITCOIN_TARBALL_OS='linux-gnu'
    if [ "${TARGET_KERNEL}" = 'OpenBSD' ] &&
      is_running_in_ci && is_running_as_root; then
      # To satisfy disk space in OpenBSD CI runner
      BITCOIN_DATA_DIRECTORY='/home/bitcoin/.bitcoin'
      mkdir -p "${BITCOIN_DATA_DIRECTORY}"
    else
      BITCOIN_DATA_DIRECTORY="${HOME}/.bitcoin"
    fi
    is_running_in_container && log_info 'Detected: running in Docker.'
    ;;
  Darwin)
    log_info 'Detected: running macOS.'
    [ "${TARGET_ARCHITECTURE}" = 'arm64' ] && display_macos_warning
    TARGET_BITCOIN_TARBALL_OS='apple-darwin'
    BITCOIN_DATA_DIRECTORY="${HOME}/Library/Application Support/Bitcoin"
    ;;
  *)
    throw_error "Unknown target kernel type '${TARGET_KERNEL}'."
    ;;
esac

readonly TARGET_BITCOIN_TARBALL_OS
readonly BITCOIN_DATA_DIRECTORY
readonly BITCOIN_CORE_CONFIG_FILE="${BITCOIN_DATA_DIRECTORY}/bitcoin.conf"
readonly BITCOIN_CORE_DEBUG_LOG_FILE="${BITCOIN_DATA_DIRECTORY}/debug.log"

check_internet_status
is_running_in_ci ||
  [ "${TARGET_KERNEL}" = 'Darwin' ] ||
  install_system_updates
install_runtime_dependencies

if command -v bitcoind > /dev/null 2>&1; then
  current_bitcoin_version="$(bitcoind --version 2> /dev/null | head -1 | cut -c23-)"
else
  current_bitcoin_version=''
fi

# If version is like 'xx.yy.zz' or 'xx.yy' or 'xx', pad it as 'xx.yy.zz.0'
case "${current_bitcoin_version}" in
  '' | *[.]*[.]*[.]*)
    CURRENT_BITCOIN_VERSION_PADDED="${current_bitcoin_version}"
    ;;
  *[.]*[.]*)
    CURRENT_BITCOIN_VERSION_PADDED="${current_bitcoin_version}.0"
    ;;
  *[.]*)
    CURRENT_BITCOIN_VERSION_PADDED="${current_bitcoin_version}.0.0"
    ;;
  *)
    CURRENT_BITCOIN_VERSION_PADDED="${current_bitcoin_version}.0.0.0"
    ;;
esac
readonly CURRENT_BITCOIN_VERSION_PADDED

if [ -n "${CURRENT_BITCOIN_VERSION_PADDED}" ]; then
  case "${target_bitcoin_version}" in
    '')
      throw_error 'Bitcoin Core target version is not set.'
      ;;
    *[.]*[.]*[.]*)
      TARGET_BITCOIN_VERSION_PADDED="${target_bitcoin_version}"
      ;;
    *[.]*[.]*)
      TARGET_BITCOIN_VERSION_PADDED="${target_bitcoin_version}.0"
      ;;
    *[.]*)
      TARGET_BITCOIN_VERSION_PADDED="${target_bitcoin_version}.0.0"
      ;;
    *)
      TARGET_BITCOIN_VERSION_PADDED="${target_bitcoin_version}.0.0.0"
      ;;
  esac
else
  TARGET_BITCOIN_VERSION_PADDED='0.0.0.0'
fi
readonly TARGET_BITCOIN_VERSION_PADDED

if [ "${CURRENT_BITCOIN_VERSION_PADDED}" = "${TARGET_BITCOIN_VERSION_PADDED}" ]; then
  log_info "Bitcoin Core ${target_bitcoin_version} was found."
elif [ "${compile_bitcoin_flag:-false}" = 'true' ] ||
  [ "${TARGET_OPERATING_SYSTEM}" = 'alpine' ] ||
  [ "${TARGET_OPERATING_SYSTEM}" = 'gentoo' ] ||
  [ "${TARGET_OPERATING_SYSTEM}" = 'FreeBSD' ] ||
  [ "${TARGET_OPERATING_SYSTEM}" = 'OpenBSD' ]; then
  log_info "Bitcoin Core ${target_bitcoin_version} not found."
  compile_bitcoin_from_source
  current_bitcoin_version="${target_bitcoin_version}"
else
  log_info "Bitcoin Core ${target_bitcoin_version} not found."
  bitcoin_tarball_download_extract_test_install
fi

[ "${TARGET_KERNEL}" != 'Darwin' ] && create_application_shortcuts

# If bitcoin.conf doesn't already exist, use default settings
[ -d "${BITCOIN_DATA_DIRECTORY}"/ ] || mkdir "${BITCOIN_DATA_DIRECTORY}"/
if [ ! -f "${BITCOIN_CORE_CONFIG_FILE}" ]; then
  log_info 'Setting the default node behavior.'
  set_bitcoin_core_option 'datadir' "${BITCOIN_DATA_DIRECTORY}"
  is_running_in_ci && set_bitcoin_core_option 'debug' 'net'
  set_bitcoin_core_option 'mempoolfullrbf' '1'
  set_bitcoin_core_option 'server' '1'
fi

# Synced data and prune checks
readonly BITCOIN_CORE_BLOCKS_DIRECTORY="${BITCOIN_DATA_DIRECTORY}/blocks"
if [ -d "${BITCOIN_CORE_BLOCKS_DIRECTORY}"/ ]; then
  case "${TARGET_KERNEL}" in
    Darwin | FreeBSD)
      INITIAL_BLOCKS_SIZE_IN_MIB="$(du -d0 -m "${BITCOIN_CORE_BLOCKS_DIRECTORY}" | cut -f1)"
      ;;
    OpenBSD)
      INITIAL_BLOCKS_SIZE_IN_MIB="$(BLOCKSIZE=1M du -d0 "${BITCOIN_CORE_BLOCKS_DIRECTORY}" | cut -f1)"
      ;;
    *)
      INITIAL_BLOCKS_SIZE_IN_MIB="$(du -d0 --block-size='1MiB' "${BITCOIN_CORE_BLOCKS_DIRECTORY}" | cut -f1)"
      ;;
  esac
else
  INITIAL_BLOCKS_SIZE_IN_MIB=0
fi
readonly INITIAL_BLOCKS_SIZE_IN_MIB
readonly BITCOIN_CORE_CHAINSTATE_DIRECTORY="${BITCOIN_DATA_DIRECTORY}/chainstate"
if [ -d "${BITCOIN_CORE_CHAINSTATE_DIRECTORY}"/ ]; then
  case "${TARGET_KERNEL}" in
    Darwin | FreeBSD)
      INITIAL_CHAINSTATE_SIZE_IN_MIB="$(du -d0 -m "${BITCOIN_CORE_CHAINSTATE_DIRECTORY}" | cut -f1)"
      ;;
    OpenBSD)
      INITIAL_CHAINSTATE_SIZE_IN_MIB="$(BLOCKSIZE=1M du -d0 "${BITCOIN_CORE_CHAINSTATE_DIRECTORY}" | cut -f1)"
      ;;
    *)
      INITIAL_CHAINSTATE_SIZE_IN_MIB="$(du -d0 --block-size='1MiB' "${BITCOIN_CORE_CHAINSTATE_DIRECTORY}" | cut -f1)"
      ;;
  esac
else
  INITIAL_CHAINSTATE_SIZE_IN_MIB=0
fi
readonly INITIAL_CHAINSTATE_SIZE_IN_MIB
readonly INITIAL_DATA_ALREADY_SYNCED_IN_MIB=$((INITIAL_BLOCKS_SIZE_IN_MIB + INITIAL_CHAINSTATE_SIZE_IN_MIB))
log_info "Found data already synced... $((INITIAL_DATA_ALREADY_SYNCED_IN_MIB / MIB_TO_GIB)) GiB."

free_space_in_mib="$(get_free_space_in_mib)"
log_info "Found free space available... $((free_space_in_mib / MIB_TO_GIB)) GiB."

## This constant will need to be adjusted over time as the chain grows
## or need to find how to generate this dynamically in a trustless way.
## The lower this number is, the more likely disk space errors during IBD.
## The higher this number is, the more likely a node will be to prune.
## The sweet spot is about 50, 75, or 100 GB more than the size of blocks/ + chainstate/ using this:
## `echo $((($(du -md0 ~/.bitcoin/blocks/ | cut -f1) + $(du -md0 ~/.bitcoin/chainstate/ | cut -f1)) / 1024))`
## which is 647 GiB, as of September 2024.
readonly ARCHIVAL_NODE_REQUIRED_DISK_IN_GIB='722'
readonly ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB=$((ARCHIVAL_NODE_REQUIRED_DISK_IN_GIB * MIB_TO_GIB))

# check if the user wants to disable pruning
if [ "${prune_value}" -eq 0 ]; then
  if [ "$((free_space_in_mib + INITIAL_DATA_ALREADY_SYNCED_IN_MIB))" -lt "${ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB}" ]; then
    throw_error "Not enough storage to disable pruning. Free up ${ARCHIVAL_NODE_REQUIRED_DISK_IN_GIB} GiB or use a positive value less than $((free_space_in_mib + INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) \(MiB\)."
  fi
  log_info 'Configuring with the disabled prune option.'
  set_bitcoin_core_option 'prune' "${prune_value}"
# check if the user passed in a prune value
elif [ "${prune_value}" -gt 0 ]; then
  if [ "$((free_space_in_mib + INITIAL_DATA_ALREADY_SYNCED_IN_MIB))" -lt "${prune_value}" ]; then
    throw_error "Prune value ${prune_value} too large. Run without setting prune or use a value less than $((free_space_in_mib + INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) \(MiB\)."
  fi
  log_info "Configuring with the ${prune_value} MiB prune option."
  set_bitcoin_core_option 'prune' "${prune_value}"
# check that a prune value doesn't already exist in the config file
elif ! grep -q -i '^prune=' "${BITCOIN_CORE_CONFIG_FILE}"; then
  if [ "${free_space_in_mib}" -ge $((ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB - INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) ]; then
    log_info 'Your node will run as an unpruned full node.'
    set_bitcoin_core_option 'prune' '0'
  elif [ "${free_space_in_mib}" -lt $((ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB / 80 - INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) ]; then
    throw_error 'You are too low on disk space to run Bitcoin Core.'
  else
    if [ "${free_space_in_mib}" -lt $((ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB / 40 - INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) ]; then
      log_warning 'Your disk space is low.'
      log_info 'Setting blocks-only mode and the minimum 0.55 GiB prune.'
      set_bitcoin_core_option 'blocksonly' '1'
      readonly PRUNE_AMOUNT_IN_MIB='550'
    else
      if [ "${free_space_in_mib}" -lt $((ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB / 12 - INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) ]; then
        readonly PRUNE_RATIO=20
      elif [ "${free_space_in_mib}" -lt $((ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB / 4 - INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) ]; then
        readonly PRUNE_RATIO=40
      elif [ "${free_space_in_mib}" -lt $((ARCHIVAL_NODE_REQUIRED_DISK_IN_MIB * 3 / 4 - INITIAL_DATA_ALREADY_SYNCED_IN_MIB)) ]; then
        readonly PRUNE_RATIO=60
      else
        readonly PRUNE_RATIO=80
      fi
      readonly PRUNE_AMOUNT_IN_MIB=$((free_space_in_mib * PRUNE_RATIO / 100))
      log_info "Pruning to $((PRUNE_AMOUNT_IN_MIB / MIB_TO_GIB)) GiB (${PRUNE_RATIO}% of the free space)."
      log_info 'You can change this in ~/.bitcoin/bitcoin.conf.'
    fi
    set_bitcoin_core_option 'prune' "${PRUNE_AMOUNT_IN_MIB}"
  fi
fi

# Memory checks
case "${TARGET_KERNEL}" in
  Darwin | FreeBSD | OpenBSD) ;;
  *)
    PHYSICAL_MEMORY_TOTAL_IN_MIB="$(get_memory_metric_in_mib 'MemTotal')" && readonly PHYSICAL_MEMORY_TOTAL_IN_MIB
    PHYSICAL_MEMORY_FREE_IN_MIB="$(get_memory_metric_in_mib 'MemAvailable')" && readonly PHYSICAL_MEMORY_FREE_IN_MIB
    SWAP_MEMORY_TOTAL_IN_MIB="$(get_memory_metric_in_mib 'SwapTotal')" && readonly SWAP_MEMORY_TOTAL_IN_MIB
    SWAP_MEMORY_FREE_IN_MIB="$(get_memory_metric_in_mib 'SwapFree')" && readonly SWAP_MEMORY_FREE_IN_MIB
    readonly MEMORY_TOTAL_IN_MIB=$((PHYSICAL_MEMORY_TOTAL_IN_MIB + SWAP_MEMORY_TOTAL_IN_MIB))
    readonly MEMORY_FREE_IN_MIB=$((PHYSICAL_MEMORY_FREE_IN_MIB + SWAP_MEMORY_FREE_IN_MIB))
    free_memory="$(awk -v mem_free_mib="${MEMORY_FREE_IN_MIB}" -v mib_gib_factor="${MIB_TO_GIB}" 'BEGIN{printf "%.1f", mem_free_mib / mib_gib_factor}')"
    TOTAL_MEMORY="$(awk -v mem_total_mib="${MEMORY_TOTAL_IN_MIB}" -v mib_gib_factor="${MIB_TO_GIB}" 'BEGIN{printf "%.1f", mem_total_mib / mib_gib_factor}')" && readonly TOTAL_MEMORY
    log_info "Checking system memory... ${free_memory} of ${TOTAL_MEMORY} GiB free."

    if [ "${MEMORY_TOTAL_IN_MIB}" -le $((1 * MIB_TO_GIB)) ] || [ "${MEMORY_FREE_IN_MIB}" -le '32' ]; then
      log_warning 'Configuring for minimal memory usage.'
      set_if_unset_bitcoin_core_option 'dbcache' '4'
      set_if_unset_bitcoin_core_option 'maxmempool' '5'
      set_if_unset_bitcoin_core_option 'maxconnections' '4'
      [ "${TARGET_KERNEL}" = 'Linux' ] && export MALLOC_ARENA_MAX=1
    elif [ "${MEMORY_TOTAL_IN_MIB}" -le $((2 * MIB_TO_GIB)) ] || [ "${MEMORY_FREE_IN_MIB}" -le '64' ]; then
      log_warning 'Configuring for reduced memory usage.'
      set_if_unset_bitcoin_core_option 'dbcache' '100'
      set_if_unset_bitcoin_core_option 'maxmempool' '50'
      set_if_unset_bitcoin_core_option 'maxconnections' '10'
      [ "${TARGET_KERNEL}" = 'Linux' ] && export MALLOC_ARENA_MAX=1
    elif [ "${MEMORY_TOTAL_IN_MIB}" -le $((4 * MIB_TO_GIB)) ] || [ "${MEMORY_FREE_IN_MIB}" -le '128' ]; then
      log_warning 'Configuring for conservative memory usage.'
      set_if_unset_bitcoin_core_option 'dbcache' '225'
      set_if_unset_bitcoin_core_option 'maxmempool' '150'
    fi
    ;;
esac

log_info 'Starting Bitcoin Core.'
if is_running_in_ci ||
  is_running_in_container ||
  [ -z "${DISPLAY:-}" ] ||
  ! command -v bitcoin-qt > /dev/null 2>&1; then
  bitcoind --daemonwait --datadir="${BITCOIN_DATA_DIRECTORY}" > /dev/null
elif [ "${TARGET_KERNEL}" = 'Darwin' ]; then
  nohup bitcoin-qt --datadir="${BITCOIN_DATA_DIRECTORY}" > /dev/null 2>&1 < /dev/null &
else
  setsid bitcoin-qt --datadir="${BITCOIN_DATA_DIRECTORY}" > /dev/null 2>&1 < /dev/null &
fi

log_info 'Checking the RPC status.'
readonly BITCOIN_RPC_TIMEOUT_SECONDS=300
if ! bitcoin-cli --datadir="${BITCOIN_DATA_DIRECTORY}" --rpcwait --rpcwaittimeout="${BITCOIN_RPC_TIMEOUT_SECONDS}" getrpcinfo > /dev/null; then
  throw_error "RPC communication failed after ${BITCOIN_RPC_TIMEOUT_SECONDS} seconds."
fi

readonly SLEEP_TIME_SECONDS='10'
blockchain_info=$(bitcoin-cli --datadir="${BITCOIN_DATA_DIRECTORY}" --rpcwait getblockchaininfo)
ibd_status=$(echo "${blockchain_info}" | jq '.initialblockdownload')

if [ "${ibd_status}" = 'true' ]; then
  if ! is_running_in_container; then
    if [ "${TARGET_KERNEL}" = 'Darwin' ]; then
      log_info 'Disabling system sleep, suspend, and hibernate.'
      caffeinate -sw "$(cat "${BITCOIN_DATA_DIRECTORY}/bitcoind.pid")" &
    elif [ "${TARGET_KERNEL}" = 'Linux' ]; then
      log_info 'Disabling system sleep, suspend, and hibernate.'
      sudo systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target > /dev/null 2>&1
    fi
    log_info "Close this Terminal window by clicking on the 'X'."
    log_info "This screen will refresh in ${SLEEP_TIME_SECONDS} seconds."
  fi
  sleep "${SLEEP_TIME_SECONDS}"
else
  log_info 'Your node has already synced the blockchain.'
fi

while [ "${ibd_status}" = 'true' ]; do
  blocks=$(echo "${blockchain_info}" | jq '.blocks')
  headers=$(echo "${blockchain_info}" | jq '.headers')
  last_block_time=$(echo "${blockchain_info}" | jq '.time')
  size_on_disk_in_mib=$(($(echo "${blockchain_info}" | jq '.size_on_disk') / BYTES_TO_KIB / KIB_TO_MIB))
  sync_progress=$(echo "${blockchain_info}" | jq '.verificationprogress')

  # Handle case of early sync (e^-8 or e^-9) by replacing scientific notation with decimal percent
  case "${sync_progress}" in
    *e*) sync_progress_percent='0.0000001' ;;
    *) sync_progress_percent="$(awk -v prog="${sync_progress}" 'BEGIN{printf "%f\n", prog * 100}')" ;;
  esac

  free_space_in_mib="$(get_free_space_in_mib)"

  clear_the_terminal
  if [ "${headers}" -eq 0 ]; then
    log_info 'Syncing the block headers (first pass).'
    headers_presync_last_log_line="$(grep 'Pre-synchronizing blockheaders' "${BITCOIN_CORE_DEBUG_LOG_FILE}" | tail -1 || true)"
    if [ -n "${headers_presync_last_log_line}" ]; then
      headers_presync_height=$(echo "${headers_presync_last_log_line}" | cut -d, -f2 | cut -d: -f2 | cut -d'(' -f1 | cut -d' ' -f2)
      headers_presync_progress_percent=$(echo "${headers_presync_last_log_line}" | cut -d~ -f2 | cut -d% -f1)
      printf 'Headers presynced:          %d\n' "${headers_presync_height}"
      printf 'Headers presync progress:   %.1f %%\n' "${headers_presync_progress_percent}"
    else
      printf 'Headers presynced:          %d\n' '0'
      printf 'Headers presync progress:   %.1f %%\n' '0.0'
    fi
  elif [ "${blocks}" -eq 0 ]; then
    log_info 'Syncing the block headers (second pass).'
    printf 'Headers synced:             %d\n' "${headers}"
    headers_sync_last_log_line="$(grep 'Synchronizing blockheaders' "${BITCOIN_CORE_DEBUG_LOG_FILE}" | tail -1 || true)"
    if [ -n "${headers_sync_last_log_line}" ]; then
      headers_sync_progress_percent="$(echo "${headers_sync_last_log_line}" | cut -d~ -f2 | cut -d% -f1)"
      printf 'Headers sync progress:      %.1f %%\n' "${headers_sync_progress_percent}"
    else
      printf 'Headers sync progress:      %.1f %%\n' '0.0'
    fi
  else
    log_info 'Syncing the blockchain. Please be patient.'
    printf 'Sync progress:              %.3f %%\n' "${sync_progress_percent}"
    printf 'Blocks remaining:           %d\n' "$((headers - blocks))"

    case "${TARGET_KERNEL}" in
      Darwin | FreeBSD | OpenBSD)
        current_chain_tip_timestamp="$(/bin/date -r "${last_block_time}" | cut -c 5-)"
        ;;
      *)
        current_chain_tip_timestamp="$(date -d @"${last_block_time}" | cut -c 5-)"
        ;;
    esac
    printf 'Current chain tip:          %s\n' "${current_chain_tip_timestamp}"

    printf '%s' 'Chain sync size:            '
    if [ "${size_on_disk_in_mib}" -gt "${MIB_TO_GIB}" ]; then
      printf '%d GiB\n' "$((size_on_disk_in_mib / MIB_TO_GIB))"
    else
      printf '%d MiB\n' "${size_on_disk_in_mib}"
    fi
  fi

  printf '%s' 'Disk free space:            '
  if [ "${free_space_in_mib}" -gt "${MIB_TO_GIB}" ]; then
    printf '%d GiB\n' "$((free_space_in_mib / MIB_TO_GIB))"
  else
    printf '%d MiB\n' "${free_space_in_mib}"
  fi

  if [ "${size_on_disk_in_mib}" -ge 1 ] && (is_running_in_ci || is_running_in_container); then
    log_success 'The blockchain download is progressing. Exiting the script.'
    exit 0
  fi

  printf '%s\n\n' 'The chain sync can take several days or even weeks.'
  printf '%s\n' "Close this Terminal window by clicking on the 'X'."
  printf '%s' "This screen will refresh in ${SLEEP_TIME_SECONDS} seconds."
  sleep "${SLEEP_TIME_SECONDS}"

  blockchain_info=$(bitcoin-cli --datadir="${BITCOIN_DATA_DIRECTORY}" --rpcwait getblockchaininfo)
  printf '\n'
  ibd_status=$(echo "${blockchain_info}" | jq '.initialblockdownload')
done

log_success 'This script has completed successfully.'
exit 0
