#!/bin/sh
#
# A minimally-interactive script for launching a Bitcoin Core node
set -o errexit
set -o nounset

check_dpkg_lock() {
  if fuser /var/lib/dpkg/lock > /dev/null 2>&1 || fuser /var/lib/dpkg/lock-frontend > /dev/null 2>&1; then
    throw_error 'Debian package manager (dpkg) is locked by another process. Try running: ps aux | grep -i apt'
  fi
}

check_internet() {
  check_int_address=$1
  check_int_port="443"
  check_int_timeout="10"
  # shellcheck disable=SC2015
  command -v torsocks > /dev/null 2>&1 && [ "$(get_os_release_type)" != 'Darwin' ] &&
    torsocks curl --silent --output /dev/null --retry 2 --connect-timeout "${check_int_timeout}" https://"${check_int_address}:${check_int_port}" > /dev/null ||
    curl --silent --output /dev/null --retry 5 --connect-timeout "${check_int_timeout}" https://"${check_int_address}:${check_int_port}" > /dev/null
}

display_macos_warning() {
  if [ "$(uname -s)" = "Darwin" ] && [ "$(uname -m)" = "arm64" ]; then
    printf '%s\n%s\n' \
      "WARNING: Your operating system has an unpatched security vulnerability called GoFetch." \
      "Avoid performing any security-critical actions and consider switching to Ubuntu Linux."
    if [ "${unattended:-false}" = false ] && ! is_running_in_ci; then
      printf '%s' "PRESS ENTER to continue or press Ctrl+C to exit... "
      read -r _
    fi
  fi
}

ensure_curl_dependency() {
  if ! command -v curl > /dev/null; then
    printf '%s' "Installing curl depencency... "
    case "$(get_os_release_type)" in
    alpine)
      apk --quiet add curl
      ;;
    debian | ubuntu)
      sudo apt-get install -y curl > /dev/null
      ;;
    fedora | rhel | centos*)
      sudo dnf install curl > /dev/null
      ;;
    arch | manjaro)
      sudo pacman -Syu --needed --noconfirm curl > /dev/null
      ;;
    suse | *opensuse*)
      sudo zypper --non-interactive --quiet install curl > /dev/null
      ;;
    *)
      if command -v apk > /dev/null; then
        apk --quiet add curl
      elif command -v apt-get > /dev/null; then
        sudo apt-get -qq install -y curl > /dev/null
      elif command -v dnf > /dev/null; then
        sudo dnf install curl > /dev/null
      elif command -v pacman > /dev/null; then
        sudo pacman -Syu --needed --noconfirm curl > /dev/null
      elif command -v zypper > /dev/null; then
        sudo zypper --non-interactive --quiet install curl > /dev/null
      else
        throw_error "PACKAGE MANAGER NOT FOUND. Please research how to install 'curl'."
      fi
      ;;
    esac
    printf '%s\n' "ok."
  fi
}

get_cursor_column() {
  stored_stty_settings=$(stty -g)
  # Set raw mode, no echo, immediate read
  stty raw -echo min 0 time 10
  # Send ANSII escape code to request cursor position
  printf "\033[6n" > /dev/tty
  # System will print the cursor's row and column
  IFS=';' read -r _ stty_column
  stty "$stored_stty_settings"
  printf '%s' "$stty_column"
}

test_get_cursor_column() {
  # Test when cursor is at the start of a line
  printf '\n'
  col=$(get_cursor_column)
  [ "$col" -ne 1 ] && throw_error "Failed: Expected 1, got $col"

  # Test when cursor is at the end of the string "test"
  printf '\n%s' "test"
  col=$(get_cursor_column)
  [ "$col" -ne 5 ] && throw_error "Failed: Expected 5, got $col"

  printf '%s\n' "All tests passed"
  return 0
}

get_free_space_in_mib() {
  if [ "$(uname -s)" = "Darwin" ]; then
    /bin/df -m "${HOME}" | awk '{print $4}' | sed 1d
  else
    df --output=avail --block-size="1MiB" "${HOME}" | sed 1d
  fi
}

get_memory_metric_in_mib() (
  metric_to_query="$1"
  awk -v metric="${metric_to_query}" \
    -v kib_mib_factor="${KIB_TO_MIB}" \
    '$0 ~ metric { printf "%d \n", $2 / kib_mib_factor }' /proc/meminfo
)

get_os_release_type() (
  if [ "$(uname -s)" = "Darwin" ]; then
    printf '%s\n' "Darwin"
  else
    os_release_id_like=$(grep "^ID_LIKE=" /etc/os-release | cut -d= -f2)
    os_release_id=$(grep "^ID=" /etc/os-release | cut -d= -f2)

    if [ -n "${os_release_id_like}" ] || [ -n "${os_release_id}" ]; then
      printf '%s\n' "${os_release_id_like:-${os_release_id}}"
    else
      throw_error "Failed to determine OS release type"
    fi
  fi
)

# shellcheck disable=SC2317
handle_error() {
  log_error "Failed to run line $1."
  handle_exit
  exit 1
}

# shellcheck disable=SC2317
handle_exit() {
  [ -n "${temp_directory:-}" ] && rm -rf -- "${temp_directory:?}"/
}

# shellcheck disable=SC2317
handle_sigint() {
  printf '\n%s\n' "Detected Ctrl+C. Exiting."
  handle_exit
  exit 0
}

install_build_dependencies_apk() {
  apk --quiet add alpine-sdk libffi-dev autoconf automake db-dev boost boost-dev libtool libevent-dev libqrencode-dev qt5-qtbase qt5-qtbase-x11 qt5-qttools-dev |
    grep -v "ICU with non-English locales" -A2 -B1 || true
}

install_build_dependencies_aptget() {
  DEBIAN_FRONTEND=noninteractive sudo apt-get -qq install --assume-yes --no-install-recommends build-essential libtool autotools-dev automake pkg-config bsdmainutils python3 libevent-dev libboost-dev libsqlite3-dev qtbase5-dev qttools5-dev qttools5-dev-tools qtwayland5 libqrencode-dev > /dev/null
  # TODO: Remove gcc-12 installation on next line when Ubuntu updates the default version of gcc to support C++ 20 features. Bitcoin Core requires gcc with support for C++ 20 features.
  DEBIAN_FRONTEND=noninteractive sudo apt-get -qq install --assume-yes --no-install-recommends gcc-12
}

install_build_dependencies_dnf() {
  sudo dnf install gcc-c++ libtool make autoconf automake python3 libevent-devel boost-devel sqlite-devel qt5-qttools-devel qt5-qtbase-devel qt5-qtwayland qrencode-devel > /dev/null
}

install_build_dependencies_pacman() {
  echo "TODO: install_build_dependencies_pacman()"
}

install_build_dependencies_zypper() {
  echo "TODO: install_build_dependencies_zypper()"
}

install_runtime_dependencies_apk() {
  dependencies_url="https://github.com/bitcoin-tools/nodebuilder/raw/master/dependencies/runtime_dependencies_apk.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${dependencies_url}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${dependencies_url}")
  if [ -n "${dependencies}" ]; then
    printf '%s\n' "${dependencies}" | xargs sudo apk --quiet add
  else
    throw_error "The list of dependencies is empty."
  fi
}

install_runtime_dependencies_aptget() {
  check_dpkg_lock
  dependencies_url="https://github.com/bitcoin-tools/nodebuilder/raw/master/dependencies/runtime_dependencies_aptget.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${dependencies_url}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${dependencies_url}")
  if [ -n "${dependencies}" ]; then
    printf '%s\n' "${dependencies}" | xargs sudo DEBIAN_FRONTEND=noninteractive apt-get -qq install --assume-yes --no-install-recommends > /dev/null
  else
    throw_error "The list of dependencies is empty."
  fi
}

install_runtime_dependencies_darwin() {
  if ! command -v git > /dev/null 2>&1; then
    printf '%s\n%s' "not found." "Installing git via the Xcode Command Line Tools... "
    # These steps were taken from: https github com/Homebrew/install/blob/aceed88a4a062e2b41dc40a7428c71309fce14c9/install.sh#L831
    # TODO: find a way to install only the git binary, not all the Xcode tools. Unattended git installation shouldn't take 20+ lines of code.
    sudo touch /tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress
    clt_label_command="/usr/sbin/softwareupdate -l | grep -B 1 -E 'Command Line Tools' | awk -F'*' '/^ *\\*/ {print \$2}' | sed -e 's/^ *Label: //' -e 's/^ *//' | sort -V | tail -n1 | tr -d '\n'"
    clt_label="$(/bin/sh -c "${clt_label_command}")"
    if [ -n "${clt_label}" ]; then
      sudo /usr/sbin/softwareupdate -i "${clt_label}" > /dev/null
    else
      throw_error "Failed to install git. Cannot find a compatible Xcode Command Line Tools package."
    fi
    sudo rm /tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress

    if command -v git > /dev/null 2>&1; then
      printf '%s\n' "ok."
    elif [ "${unattended}" = true ]; then
      throw_error "Failed to install Xcode Command Line Tools. Try re-running without -u/--unattended or manually installing git."
    else
      printf '%s\n%s\n' "failed." "Installing the Command Line Tools (expect a popup window)."
      /usr/bin/xcode-select --install
      printf '%s\n' "PRESS ENTER after you've completed the installation via the popup window."
      read -r _
      if ! command -v git > /dev/null 2>&1; then
        throw_error "Failed to install git via the Xcode Command Line Tools. Try manually installing git"
      fi
    fi
  fi
}

install_runtime_dependencies_dnf() {
  dependencies_url="https://github.com/bitcoin-tools/nodebuilder/raw/master/dependencies/runtime_dependencies_dnf.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${dependencies_url}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${dependencies_url}")
  if [ -n "${dependencies}" ]; then
    printf '%s\n' "${dependencies}" | xargs sudo dnf --assumeyes --quiet install > /dev/null
  else
    throw_error "The list of dependencies is empty."
  fi
}

install_runtime_dependencies_pacman() {
  dependencies_url="https://github.com/bitcoin-tools/nodebuilder/raw/master/dependencies/runtime_dependencies_pacman.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${dependencies_url}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${dependencies_url}")
  if [ -n "${dependencies}" ]; then
    printf '%s\n' "${dependencies}" | xargs sudo pacman -Syu --needed --noconfirm --quiet > dev/null
  else
    throw_error "The list of dependencies is empty."
  fi
}

install_runtime_dependencies_zypper() {
  dependencies_url="https://github.com/bitcoin-tools/nodebuilder/raw/master/dependencies/runtime_dependencies_zypper.txt"
  command -v torsocks > /dev/null 2>&1 &&
    dependencies=$(torsocks curl --fail --silent --show-error --location --retry 2 "${dependencies_url}") ||
    dependencies=$(curl --fail --silent --show-error --location --retry 5 "${dependencies_url}")
  if [ -n "${dependencies}" ]; then
    printf '%s\n' "${dependencies}" | xargs sudo zypper --non-interactive --quiet install > /dev/null
  else
    throw_error "The list of dependencies is empty."
  fi
}

install_system_updates_apk() {
  apk update --quiet && apk upgrade --quiet
}

install_system_updates_aptget() {
  check_dpkg_lock
  stderr_install_log_file="${temp_directory}/stderr_install.log"
  sudo apt-get -qq update && sudo NEEDRESTART_MODE=a apt-get -qq dist-upgrade --assume-yes > /dev/null 2> "${stderr_install_log_file}"
  grep -v "apt-utils" "${stderr_install_log_file}" >&2 || true
  rm "${stderr_install_log_file}"
}

install_system_updates_dnf() {
  sudo dnf --assumeyes --quiet upgrade > /dev/null
}

install_system_updates_pacman() {
  sudo pacman -Syu --noconfirm --quiet > /dev/null
}

install_system_updates_zypper() {
  sudo zypper --non-interactive --quiet dist-upgrade > /dev/null
}

is_running_in_ci() {
  if [ "${CI:-false}" = "true" ]; then
    return 0
  else
    return 1 #1=false
  fi
}

is_running_in_container() {
  if [ -f /proc/1/cgroup ] && [ "$(grep -c 'docker\|lxc\|actions_job' /proc/1/cgroup)" -gt 0 ]; then
    return 0
  elif [ -f /proc/1/mountinfo ] && [ "$(grep -c 'docker\|lxc\|actions_job' /proc/1/mountinfo)" -gt 0 ]; then
    return 0
  else
    return 1 #1=false
  fi
}

is_valid_bitcoin_version() {
  if [ -z "$1" ]; then
    throw_error "No arguemnt passed into is_valid_bitcoin_version"
  fi
  bitcoin_version_to_check="$1"
  valid_bitcoin_version_list="0.10.0 0.10.1 0.10.2 0.10.3 0.10.4 0.11.0 \
    0.11.1 0.11.2 0.12.0 0.12.1 0.13.0 0.13.1 0.13.2 \0.14.3 0.15.2 0.16.3 \
    0.17.0 0.17.0.1 0.17.1 0.17.2 0.18.0 0.18.1 0.19.0 0.19.0.1 0.19.1 0.20.0 \
    0.20.1 0.20.2 0.21.0 0.21.1 0.21.2 0.9.5 22.0 22.1 23.0 23.1 23.2 24.0 \
    24.0.1 24.1 24.2 25.0 25.1 25.2 26.0 26.1 27.0"
  for version in $valid_bitcoin_version_list; do
    if [ "${bitcoin_version_to_check}" = "${version}" ]; then
      return 0
    fi
  done
  return 1
}

log_error() {
  [ "$(get_cursor_column)" -gt 0 ] && printf '\n'
  printf '%s\n' "[$(date +'%Y-%m-%dT%H:%M:%S')] ERROR: $*" >&2
}

print_usage() {
  printf '%s\n\n' "Usage: $0 [options]"
  printf '%s\n' "Options:"
  printf '%s\n' "-b, --bitcoin-version   Specify the Bitcoin version"
  printf '%s\n' "-c, --compile           Build Bitcoin from source"
  printf '%s\n' "-h, --help              Display this help message"
  printf '%s\n' "-p, --prune             Set a prune value in MiB"
  printf '%s\n' "-t, --test              Run unit tests on functions"
  printf '%s\n' "-u, --unattended        Run in non-interactive mode"
}

run_unit_tests() {
  printf '%s' "Testing get_cursor_column..."
  test_get_cursor_column
  printf '%s\n' "PASS"
  return 0
}

set_bitcoin_core_option() (
  option="$1"
  value="$2"
  if [ -f "${bitcoin_core_config_file:?}" ]; then
    sed -i.bak "/^${option}=/d" "${bitcoin_core_config_file:?}"
    rm "${bitcoin_core_config_file:?}.bak"
  else
    install -m 600 /dev/null "${bitcoin_core_config_file:?}"
  fi
  printf '%s\n' "${option}=${value}" >> "${bitcoin_core_config_file:?}"
)

# This function sets a Bitcoin Core option in the configuration file if it's not already set.
set_if_unset_bitcoin_core_option() (
  option="$1"
  value="$2"
  if [ ! -f "${bitcoin_core_config_file:?}" ]; then
    install -m 600 /dev/null "${bitcoin_core_config_file:?}"
  fi
  if [ "$(grep -c -i "^${option}=" "${bitcoin_core_config_file:?}")" = "0" ]; then
    printf '%s\n' "${option}=${value}" >> "${bitcoin_core_config_file:?}"
  fi
)

throw_error() {
  if [ $# -gt 1 ]; then
    log_error "$@"
  elif [ $# -eq 1 ]; then
    log_error "$1"
  else
    log_error "Unknown error thrown at line ${LINENO:-}"
  fi
  handle_exit
  exit 1
}

target_bitcoin_version="27.0"

temp_directory=""
compile_bitcoin=false
prune_value="-1"
unattended=false
unit_tests=false

while [ $# -gt 0 ]; do
  case "$1" in
  -b | --bitcoin-version)
    if [ $# -eq 1 ]; then
      throw_error "-B/--bitcoin-versoin requires an argument"
    fi
    if is_valid_bitcoin_version "$2"; then
      target_bitcoin_version="$2"
    else
      throw_error "The Bitcoin version '$2' is not valid. Please use a value such as '26.0' from https://bitcoincore.org/bin/"
    fi
    shift
    ;;
  -c | --compile)
    compile_bitcoin=true
    ;;
  -h | --help)
    print_usage
    exit 0
    ;;
  -p | --prune)
    if [ $# -eq 1 ]; then
      throw_error "-p/--prune requires an argument"
    fi
    case $2 in
    *[!0-9]*) # if $2 contains any non-numeric characters
      throw_error "The prune value '$2' must be a positive integer or zero to disable pruning"
      ;;
    *) ;;
    esac
    if [ "$2" -gt 0 ] && [ "$2" -lt "550" ]; then
      throw_error "The prune value '$2' must be at least 550 (MiB) or zero to disable pruning"
    fi
    prune_value="$2"
    shift
    ;;
  -t | --test)
    unit_tests=true
    ;;
  -u | --unattended)
    unattended=true
    ;;
  *)
    printf '%s\n%s\n' "Error: '$1' is invalid." "Use -h or --help for available options."
    exit 1
    ;;
  esac
  shift
done

[ "${unit_tests}" = "true" ] && run_unit_tests

trap 'if [ $? -eq 0 ]; then handle_exit; else handle_error ${LINENO:-}; fi' EXIT
trap handle_sigint INT

readonly BYTES_TO_KIB=1024
readonly KIB_TO_MIB="${BYTES_TO_KIB}"
readonly MIB_TO_GIB="${BYTES_TO_KIB}"

temp_directory="$(mktemp -d)"
target_bitcoin_architecture="$(uname -m)"
user_data_dir="${XDG_DATA_HOME:-${HOME}/.local/share}"
shortcut_image_file="${user_data_dir}/images/bitcoin.png"
shortcut_image_source="https://github.com/bitcoin-tools/nodebuilder/raw/master/resources/data/bitcoin.png"

if is_running_in_container; then
  printf '%s\n' "Detected: running in a container."
fi

if ! command -v sudo > /dev/null 2>&1; then
  throw_error "The dependency 'sudo' is not installed."
elif is_running_in_ci ||
  is_running_in_container ||
  sudo --validate --noninteractive > /dev/null 2>&1; then
  :
else
  printf '%s\n' "Please enter your sudo password if requested."
  sudo --validate
fi

clear
case "$(uname -s)" in
Linux)
  printf '%s\n' "Detected: running on Linux."
  target_bitcoin_operating_system="linux-gnu"
  bitcoin_core_data_dir="${HOME}/.bitcoin"
  ensure_curl_dependency
  printf '%s' "Checking internet status... "
  ( (check_internet 1.1.1.1 ||
    check_internet 1.1.0.0 ||
    check_internet 9.9.9.9 ||
    check_internet 9.9.9.11) &&
    check_internet bitcoincore.org) ||
    throw_error "Check for active internet failed."
  printf '%s\n%s' "ok." "Performing a system upgrade... "
  case "$(get_os_release_type)" in
  alpine)
    install_system_updates_apk
    ;;
  debian | ubuntu)
    install_system_updates_aptget
    ;;
  fedora | rhel | centos*)
    install_system_updates_dnf
    ;;
  arch | manjaro)
    install_system_updates_pacman
    ;;
  suse | *opensuse*)
    install_system_updates_zypper
    ;;
  *)
    if command -v apk > /dev/null; then
      install_system_updates_apk
    elif command -v apt-get > /dev/null; then
      install_system_updates_aptget
    elif command -v dnf > /dev/null; then
      install_system_updates_dnf
    elif command -v pacman > /dev/null; then
      install_system_updates_pacman
    elif command -v zypper > /dev/null; then
      install_system_updates_zypper
    else
      throw_error "This version of Linux is not supported."
    fi
    ;;
  esac

  # Stop running if the Docker container base image is outdated
  if [ -f /var/run/reboot-required ] && is_running_in_container; then
    throw_error "The Docker base image is outdated. Please open an issue at github.com/bitcoin-tools/nodebuilder."
  # Reboot the system unless it's running in CI/CD
  elif [ -f /var/run/reboot-required ] && ! is_running_in_ci; then
    printf '\n%s\n%s\n' "REBOOT REQUIRED to upgrade the following:" "$(cat /var/run/reboot-required.pkgs)"
    if [ "${unattended}" = false ]; then
      printf '\n%s' "PRESS ENTER to reboot or press Ctrl+C to exit... "
      read -r _
    fi
    printf '%s\n' "Rebooting."
    sudo reboot
    exit 0
  fi
  printf '%s\n' "ok."

  printf '%s' "Ensuring runtime dependencies... "
  case "$(get_os_release_type)" in
  alpine)
    install_runtime_dependencies_apk
    ;;
  debian | ubuntu)
    install_runtime_dependencies_aptget
    ;;
  fedora | rhel)
    install_runtime_dependencies_dnf
    ;;
  arch | manjaro)
    install_runtime_dependencies_pacman
    ;;
  suse | *opensuse*)
    install_runtime_dependencies_zypper
    ;;
  *)
    install_runtime_command_function=""
    for package_manager in \
      apk \
      apt-get \
      dnf \
      pacman \
      zypper; do
      if command -v "${package_manager}" > /dev/null; then
        install_runtime_command_function="install_runtime_dependencies_$(echo "${package_manager}" | tr -d '-')"
        break
      fi
    done

    if [ -n "${install_runtime_command_function}" ]; then
      "${install_runtime_command_function}"
    else
      throw_error "Unknown package manager. This version of Linux is not supported."
    fi
    ;;
  esac
  printf '%s\n' "ok."
  ;;
Darwin)
  target_bitcoin_operating_system="apple-darwin"
  bitcoin_core_data_dir="${HOME}/Library/Application Support/Bitcoin"
  printf '%s\n%s' "Detected: running on macOS." "Checking internet status... "
  ( (check_internet 1.1.1.1 ||
    check_internet 1.1.0.0 ||
    check_internet 9.9.9.9 ||
    check_internet 9.9.9.11) &&
    check_internet bitcoincore.org) ||
    throw_error "Check for active internet failed."
  printf '%s\n' "ok."
  display_macos_warning
  printf '%s' "Checking for git... "
  install_runtime_dependencies_darwin
  printf '%s\n' "ok."
  ;;
MINGW*)
  throw_error "Windows is not supported. Instead, use WSL (Windows Subsystem for Linux)."
  ;;
*)
  throw_error "Your operating system is not supported."
  ;;
esac

printf '%s' "Checking for Bitcoin Core ${target_bitcoin_version}... "
if command -v bitcoind > /dev/null 2>&1; then
  current_bitcoin_version="$(bitcoind --version 2> /dev/null | head -1 | cut -c23-)"
else
  current_bitcoin_version=""
fi

# If version is like 'xx.yy', pad it as 'xx.yy.0'
case "${current_bitcoin_version}" in
*[.]*[.]*)
  current_bitcoin_version_padded="${current_bitcoin_version}"
  ;;
*)
  current_bitcoin_version_padded="${current_bitcoin_version}.0"
  ;;
esac
case "${target_bitcoin_version}" in
*[.]*[.]*)
  target_bitcoin_version_padded="${target_bitcoin_version}"
  ;;
*)
  target_bitcoin_version_padded="${target_bitcoin_version}.0"
  ;;
esac

if [ "${current_bitcoin_version_padded}" = "${target_bitcoin_version_padded}" ]; then
  printf '%s\n' "ok."
elif [ "${compile_bitcoin:-false}" = true ] || [ "$(get_os_release_type)" = "alpine" ]; then
  printf '%s\n  %s' "no." "Ensuring compile dependencies... "
  compile_directory="${temp_directory}/compile_bitcoin"
  stderr_compile_log_file="${temp_directory}/stderr_install.log"
  case "$(get_os_release_type)" in
  alpine)
    install_build_dependencies_apk
    ;;
  debian | ubuntu)
    install_build_dependencies_aptget
    ;;
  fedora | rhel)
    install_build_dependencies_dnf
    ;;
  arch | manjaro)
    install_build_dependencies_pacman
    ;;
  suse | *opensuse*)
    install_build_dependencies_zypper
    ;;
  Darwin)
    sudo printf '' && NONINTERACTIVE=1 /bin/bash -c "$(curl --fail --silent --show-error --location --retry 5 \
      https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" > /dev/null 2>&1
    brew install --quiet automake boost libevent libtool pkg-config python qrencode qt@5 > /dev/null
    ;;
  *)
    install_build_command_function=""
    for package_manager in \
      apk \
      apt-get \
      dnf \
      pacman \
      zypper; do
      if command -v "${package_manager}" > /dev/null; then
        install_build_command_function="install_build_dependencies_$(echo "${package_manager}" | tr -d '-')"
        break
      fi
    done
    if [ -n "${install_build_command_function}" ]; then
      "${install_build_command_function}"
    else
      printf '%s\n  %s\n' "failed." "Unable to determine build dependencies. Attempting to compile without verifying dependencies."
    fi
    ;;
  esac
  printf '%s\n  %s' "ok." "Downloading Bitcoin source code... "
  # shellcheck disable=SC2015
  command -v torsocks > /dev/null 2>&1 && [ "$(get_os_release_type)" != 'Darwin' ] &&
    torsocks git clone --branch "v${target_bitcoin_version}" --single-branch --depth 1 --quiet -c advice.detachedHead=false https://github.com/bitcoin/bitcoin.git "${compile_directory}" ||
    git clone --branch "v${target_bitcoin_version}" --single-branch --depth 1 --quiet -c advice.detachedHead=false https://github.com/bitcoin/bitcoin.git "${compile_directory}"
  cd "${compile_directory}"/
  printf '%s\n  %s' "ok." "Analyzing hardware configuration... "
  ./autogen.sh > /dev/null 2> "${stderr_compile_log_file}"
  grep -v "build-aux" "${stderr_compile_log_file}" >&2 || true
  printf '%s\n  %s' "ok." "Configuring the build environment... "
  if [ "$(get_os_release_type)" = "Darwin" ]; then
    ./configure CC=clang CXX=clang++ --without-bdb --enable-suppress-external-warnings > /dev/null 2> "${stderr_compile_log_file}"
  else
    ./configure --without-bdb --enable-suppress-external-warnings > /dev/null 2> "${stderr_compile_log_file}"
  fi
  grep -v \
    -e "libzmq" \
    -e "xgettext" \
    "${stderr_compile_log_file}" >&2 || true
  printf '%s\n  %s' "ok." "Compiling source code, please wait... "
  if [ "$(get_os_release_type)" = "Darwin" ]; then
    compile_jobs_count="$(($(sysctl -n hw.physicalcpu) + 1))"
  else
    compile_jobs_count="$(($(nproc) + 1))"
  fi
  make --jobs "${compile_jobs_count}" > /dev/null 2>&1
  printf '%s\n  %s' "ok." "Running compile checks, please wait... "
  make --jobs "${compile_jobs_count}" check > /dev/null 2> "${stderr_compile_log_file}"
  # exclude the two lines before and after "Ran 3 tests in " in make check's stdout
  sed -n '1N;2N;/Ran 3 tests in /{N;N;d;};P;N;D' "${stderr_compile_log_file}" >&2
  printf '%s\n  %s' "ok." "Installing Bitcoin Core... "
  make install > /dev/null 2>&1 || sudo make install > /dev/null
  printf '%s\n' "ok."
  cd - > /dev/null
  rm "${stderr_compile_log_file}"
  rm -rf "${compile_directory:?}"/
  current_bitcoin_version="${target_bitcoin_version}"
else
  printf '%s\n' "no."
  bitcoin_core_extract_dir="${temp_directory}/bitcoin-core"
  bitcoin_install_bin_source="${bitcoin_core_extract_dir}/bin"
  bitcoin_install_lib_source="${bitcoin_core_extract_dir}/lib"
  bitcoin_install_include_source="${bitcoin_core_extract_dir}/include"
  bitcoin_install_man_source="${bitcoin_core_extract_dir}/share/man/man1"
  bitcoin_install_destination="/usr/local"
  bitcoin_install_bin_destination="${bitcoin_install_destination}/bin"
  bitcoin_install_lib_destination="${bitcoin_install_destination}/lib"
  bitcoin_install_include_destination="${bitcoin_install_destination}/include"
  bitcoin_install_man_destination="${bitcoin_install_destination}/share/man/man1"

  bitcoin_tarball_filename="bitcoin-${target_bitcoin_version}-${target_bitcoin_architecture}-${target_bitcoin_operating_system}.tar.gz"
  bitcoin_tarball_destination_file="${HOME}/Downloads/${bitcoin_tarball_filename}"

  if ! [ -f "${bitcoin_tarball_destination_file}" ]; then
    bitcoin_source="https://bitcoincore.org/bin/bitcoin-core-${target_bitcoin_version}"
    bitcoin_tarball_file_source="${bitcoin_source}/${bitcoin_tarball_filename}"
    bitcoin_hash_filename="SHA256SUMS"
    bitcoin_hash_file_source="${bitcoin_source}/${bitcoin_hash_filename}"
    gpg_signatures_filename="SHA256SUMS.asc"
    gpg_signatures_file_source="${bitcoin_source}/${gpg_signatures_filename}"
    gpg_good_signatures_required="7"
    guix_sigs_repo="https://github.com/bitcoin-core/guix.sigs.git"
    bitcoin_tarball_temporary_file="${temp_directory}/${bitcoin_tarball_filename}"
    bitcoin_hash_file="${temp_directory}/${bitcoin_hash_filename}"
    gpg_signatures_file="${temp_directory}/${gpg_signatures_filename}"
    guix_sigs_temporary_dir="${temp_directory}/guix.sigs"
    guix_sigs_destination_dir="${HOME}/Downloads/guix.sigs"
    printf '  %s' "Downloading Bitcoin Core... "
    if command -v torsocks > /dev/null 2>&1 && [ "$(get_os_release_type)" != 'Darwin' ]; then
      torsocks curl --fail --silent --show-error --location --retry 2 --output "${bitcoin_hash_file}" "${bitcoin_hash_file_source}" ||
        curl --fail --silent --show-error --location --retry 5 --output "${bitcoin_hash_file}" "${bitcoin_hash_file_source}"
      torsocks curl --fail --silent --show-error --location --retry 2 --output "${gpg_signatures_file}" "${gpg_signatures_file_source}" ||
        curl --fail --silent --show-error --location --retry 5 --output "${gpg_signatures_file}" "${gpg_signatures_file_source}"
      torsocks curl --fail --silent --show-error --location --retry 2 --output "${bitcoin_tarball_temporary_file}" "${bitcoin_tarball_file_source}" ||
        curl --fail --silent --show-error --location --retry 5 --output "${bitcoin_tarball_temporary_file}" "${bitcoin_tarball_file_source}"
    else
      curl --fail --silent --show-error --location --retry 5 --output "${bitcoin_hash_file}" "${bitcoin_hash_file_source}"
      curl --fail --silent --show-error --location --retry 5 --output "${gpg_signatures_file}" "${gpg_signatures_file_source}"
      curl --fail --silent --show-error --location --retry 5 --output "${bitcoin_tarball_temporary_file}" "${bitcoin_tarball_file_source}"
    fi
    printf '%s\n' "ok."

    printf '  %s' "Validating the checksum... "
    cd "${temp_directory}"/
    if command -v sha256sum > /dev/null; then
      sha256_check="$(grep "${bitcoin_tarball_filename}" "${bitcoin_hash_filename}" | sha256sum --check 2> /dev/null)"
    elif command -v shasum > /dev/null; then
      sha256_check="$(grep "${bitcoin_tarball_filename}" "${bitcoin_hash_filename}" | shasum -a 256 --check 2> /dev/null)"
    else
      throw_error "Either 'sha256sum' or 'shasum' must on PATH."
    fi
    cd "${HOME}"/
    case "${sha256_check}" in
    *"OK"*) ;;
    *)
      throw_error "INVALID CHECKSUM. The download has failed. This script cannot continue due to security concerns. Please review the temporary file ${temp_directory}/${bitcoin_hash_file}."
      ;;
    esac
    printf '%s\n' "ok."

    printf '  %s' "Validating the signatures... "
    if [ -d "${guix_sigs_destination_dir}"/ ]; then
      gpg --quiet --import "${guix_sigs_destination_dir}"/builder-keys/*.gpg
    else
      # shellcheck disable=SC2015
      command -v torsocks > /dev/null 2>&1 && [ "$(get_os_release_type)" != 'Darwin' ] &&
        torsocks git clone --single-branch --depth 1 --quiet "${guix_sigs_repo}" "${guix_sigs_temporary_dir}" ||
        git clone --single-branch --depth 1 --quiet "${guix_sigs_repo}" "${guix_sigs_temporary_dir}"
      gpg --quiet --import "${guix_sigs_temporary_dir}"/builder-keys/*.gpg
    fi
    gpg_good_signature_count=$(gpg --verify "${gpg_signatures_file}" 2>&1 | grep -c "^gpg: Good signature from ")
    if [ "${gpg_good_signature_count}" -ge "${gpg_good_signatures_required}" ]; then
      printf '%s\n' "${gpg_good_signature_count} good."
      [ -d "$(dirname "${bitcoin_tarball_destination_file}")" ] || mkdir -p "$(dirname "${bitcoin_tarball_destination_file}")"
      mv "${bitcoin_tarball_temporary_file}" "${bitcoin_tarball_destination_file}"
      [ -d "${guix_sigs_destination_dir}"/ ] || mv "${guix_sigs_temporary_dir}" "${guix_sigs_destination_dir}"
      rm "${bitcoin_hash_file}"
      rm "${gpg_signatures_file}"
    else
      throw_error "INVALID SIGNATURES. The download has failed. This script cannot continue due to security concerns. Please review the temporary file ${temp_directory}/${gpg_signatures_file}."
    fi
  fi

  printf '  %s' "Extracting Bitcoin Core... "
  [ -d "${bitcoin_core_extract_dir}"/ ] || mkdir "${bitcoin_core_extract_dir}"
  tar -xzf "${bitcoin_tarball_destination_file}" -C "${bitcoin_core_extract_dir}"/ --strip-components=1
  printf '%s\n' "ok."

  printf '  %s' "Running the unit tests... "
  if [ "${target_bitcoin_architecture}" = "arm64" ]; then
    codesign -s - "${bitcoin_install_bin_source}"/test_bitcoin
  fi
  unit_test_response="$("${bitcoin_install_bin_source}"/test_bitcoin 2>&1)"
  case "${unit_test_response}" in
  *"No errors detected"*) ;;
  *)
    printf '%s\n' "\n${unit_test_response}"
    throw_error "Unit tests failed."
    ;;
  esac
  printf '%s\n  %s' "ok." "Installing Bitcoin Core... "
  [ -d "${bitcoin_install_lib_destination}" ] || mkdir -p "${bitcoin_install_lib_destination}" 2> /dev/null || sudo mkdir "${bitcoin_install_lib_destination}" || throw_error "Unable to create directory ${bitcoin_install_lib_destination}."
  case "$(uname -s)" in
  Linux)
    sudo cp "${bitcoin_install_lib_source}"/libbitcoinconsensus.so.0.0.0 "${bitcoin_install_lib_destination}"/libbitcoinconsensus.so.0.0.0
    (cd "${bitcoin_install_lib_destination}"/ && { sudo ln -s -f libbitcoinconsensus.so.0.0.0 libbitcoinconsensus.so.0 || { sudo rm -f libbitcoinconsensus.so.0 && sudo ln -s libbitcoinconsensus.so.0.0.0 libbitcoinconsensus.so.0; }; })
    (cd "${bitcoin_install_lib_destination}"/ && { sudo ln -s -f libbitcoinconsensus.so.0.0.0 libbitcoinconsensus.so || { sudo rm -f libbitcoinconsensus.so && sudo ln -s libbitcoinconsensus.so.0.0.0 libbitcoinconsensus.so; }; })
    PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin:/sbin" ldconfig -n "${bitcoin_install_lib_destination}"
    ;;
  Darwin)
    sudo cp "${bitcoin_install_lib_source}"/libbitcoinconsensus.0.dylib "${bitcoin_install_lib_destination}"/libbitcoinconsensus.0.dylib
    (cd "${bitcoin_install_lib_destination}"/ && { sudo ln -s -f libbitcoinconsensus.0.dylib libbitcoinconsensus.dylib || { sudo rm -f libbitcoinconsensus.dylib && sudo ln -s libbitcoinconsensus.0.dylib libbitcoinconsensus.dylib; }; })
    sudo update_dyld_shared_cache

    if [ "${target_bitcoin_architecture}" = "arm64" ]; then
      for bitcoin_executable in bitcoin-cli bitcoin-qt bitcoin-tx bitcoin-util bitcoin-wallet bitcoind; do
        codesign -s - "${bitcoin_install_bin_source}/${bitcoin_executable}"
      done
    fi
    ;;
  esac

  [ -d "${bitcoin_install_bin_destination}" ] || mkdir -p "${bitcoin_install_bin_destination}" 2> /dev/null || sudo mkdir "${bitcoin_install_bin_destination}" || throw_error "Unable to create directory ${bitcoin_install_bin_destination}."
  for bitcoin_executable in bitcoind bitcoin-qt bitcoin-cli bitcoin-tx bitcoin-util bitcoin-wallet test_bitcoin; do
    sudo install -c "${bitcoin_install_bin_source}/${bitcoin_executable}" "${bitcoin_install_bin_destination}/"
  done

  [ -d "${bitcoin_install_include_destination}" ] || mkdir -p "${bitcoin_install_include_destination}" 2> /dev/null || sudo mkdir "${bitcoin_install_include_destination}" || throw_error "Unable to create directory ${bitcoin_install_include_destination}."
  sudo install -c -m 644 "${bitcoin_install_include_source}"/bitcoinconsensus.h "${bitcoin_install_include_destination}/"

  [ -d "${bitcoin_install_man_destination}" ] || mkdir -p "${bitcoin_install_man_destination}" 2> /dev/null || sudo mkdir -p "${bitcoin_install_man_destination}" || throw_error "Unable to create directory ${bitcoin_install_man_destination}."
  for man_page in bitcoind.1 bitcoin-qt.1 bitcoin-cli.1 bitcoin-tx.1 bitcoin-util.1 bitcoin-wallet.1; do
    sudo install -c -m 644 "${bitcoin_install_man_source}/${man_page}" "${bitcoin_install_man_destination}/"
  done
  printf '%s\n' "ok."

  printf '  %s' "Removing installation files... "
  rm -r "${bitcoin_core_extract_dir:?}/"
  rm -r "${temp_directory:?}/"
  printf '%s\n' "ok."
fi

if [ "$(uname -s)" != "Darwin" ]; then
  printf '%s' "Creating application shortcuts... "
  desktop_path="${HOME}/Desktop"
  applications_path="${user_data_dir}/applications"
  shortcut_filename="bitcoin_core.desktop"

  [ -d "$(dirname "${shortcut_image_file}")" ] || mkdir -p "$(dirname "${shortcut_image_file}")"
  if ! [ -f "${shortcut_image_file}" ]; then
    # shellcheck disable=SC2015
    if command -v torsocks > /dev/null 2>&1 && [ "$(get_os_release_type)" != 'Darwin' ] &&
      torsocks curl --fail --silent --show-error --location --retry 2 --head "${shortcut_image_source}" | grep -q "HTTP/[0-9.]* 200" ||
      curl --fail --silent --show-error --location --retry 5 --head "${shortcut_image_source}" | grep -q "HTTP/[0-9.]* 200"; then
      command -v torsocks > /dev/null 2>&1 && [ "$(get_os_release_type)" != 'Darwin' ] &&
        torsocks curl --fail --silent --show-error --location --retry 2 --output "${shortcut_image_file}" "${shortcut_image_source}" ||
        curl --fail --silent --show-error --location --retry 5 --output "${shortcut_image_file}" "${shortcut_image_source}"
    else
      throw_error "Bitcoin image file doesn't exist at ${shortcut_image_source}"
    fi
  fi

  ## Create .desktop on the user's Desktop and "Show Applications" directories
  [ -d "${desktop_path}" ] || mkdir -p "${desktop_path}"
  [ -d "${applications_path}" ] || mkdir -p "${applications_path}"
  cat << EOF | tee "${applications_path}"/"${shortcut_filename}" > "${desktop_path}"/"${shortcut_filename}"
[Desktop Entry]
Name=Bitcoin Core
Comment=Launch Bitcoin Core
Exec=sh -c 'if command -v bitcoin-qt >/dev/null 2>&1; then bitcoin-qt; else bitcoind --daemonwait; fi'
Icon=${shortcut_image_file}
Terminal=false
StartupWMClass=Bitcoin Core
Type=Application
Categories=Application;
MimeType=application/bitcoin-paymentrequest;application/bitcoin-payment;application/bitcoin-paymentack;x-scheme-handler/bitcoin;
EOF
  chmod u+x "${applications_path}"/"${shortcut_filename}"
  chmod u+x "${desktop_path}"/"${shortcut_filename}"
  ## Make the desktop shortcut trusted
  if is_running_in_ci || is_running_in_container; then
    :
  else
    gio set "${desktop_path}"/"${shortcut_filename}" "metadata::trusted" true
  fi
  printf '%s\n' "ok."
fi

# If bitcoin.conf doesn't already exist, use default settings
[ -d "${bitcoin_core_data_dir}"/ ] || mkdir "${bitcoin_core_data_dir}"/
bitcoin_core_config_file="${bitcoin_core_data_dir}/bitcoin.conf"
if [ ! -f "${bitcoin_core_config_file}" ]; then
  printf '%s' "Setting the default node behavior... "
  is_running_in_ci && set_bitcoin_core_option "debug" "net"
  set_bitcoin_core_option "mempoolfullrbf" "1"
  set_bitcoin_core_option "server" "1"
  printf '%s\n' "ok."
fi

case "$(uname -s)" in
Darwin) ;; #TODO: Add macOS memory check
*)
  printf '%s' "Checking the memory on your system... "
  physical_memory_total_in_mib="$(get_memory_metric_in_mib 'MemTotal')"
  physical_memory_free_in_mib="$(get_memory_metric_in_mib 'MemAvailable')"
  swap_memory_total_in_mib="$(get_memory_metric_in_mib 'SwapTotal')"
  swap_memory_free_in_mib="$(get_memory_metric_in_mib 'SwapFree')"
  memory_total_in_mib=$((physical_memory_total_in_mib + swap_memory_total_in_mib))
  memory_free_in_mib=$((physical_memory_free_in_mib + swap_memory_free_in_mib))
  printf '%0.1f of %0.1f GiB free.\n' \
    "$(awk -v mem_free_mib="${memory_free_in_mib}" -v mib_gib_factor="${MIB_TO_GIB}" 'BEGIN{printf "%f\n", mem_free_mib / mib_gib_factor}')" \
    "$(awk -v mem_total_mib="${memory_total_in_mib}" -v mib_gib_factor="${MIB_TO_GIB}" 'BEGIN{printf "%f\n", mem_total_mib / mib_gib_factor}')"

  if [ "${memory_total_in_mib}" -le $((2 * MIB_TO_GIB)) ] || [ "${memory_free_in_mib}" -le "64" ]; then
    printf '%s' "Configuring for minimal memory usage... "
    set_if_unset_bitcoin_core_option "dbcache" "4"
    set_if_unset_bitcoin_core_option "maxmempool" "5"
    set_if_unset_bitcoin_core_option "maxconnections" "4"
    [ "$(uname -s)" = "Linux" ] && export MALLOC_ARENA_MAX=1
    printf '%s\n' "ok."
  elif [ "${memory_total_in_mib}" -le $((4 * MIB_TO_GIB)) ] || [ "${memory_free_in_mib}" -le "128" ]; then
    printf '%s' "Configuring for reduced memory usage... "
    set_if_unset_bitcoin_core_option "dbcache" "100"
    set_if_unset_bitcoin_core_option "maxmempool" "50"
    set_if_unset_bitcoin_core_option "maxconnections" "10"
    [ "$(uname -s)" = "Linux" ] && export MALLOC_ARENA_MAX=1
    printf '%s\n' "ok."
  elif [ "${memory_total_in_mib}" -le $((8 * MIB_TO_GIB)) ] || [ "${memory_free_in_mib}" -le "256" ]; then
    printf '%s' "Configuring for conservative memory usage... "
    set_if_unset_bitcoin_core_option "dbcache" "225"
    set_if_unset_bitcoin_core_option "maxmempool" "150"
    printf '%s\n' "ok."
  fi
  ;;
esac

printf '%s' "Checking data already synced... "
bitcoin_core_blocks_dir="${bitcoin_core_data_dir}/blocks"
bitcoin_core_chainstate_dir="${bitcoin_core_data_dir}/chainstate"
blocks_size_in_mib="0"
chainstate_size_in_mib="0"
if [ -d "${bitcoin_core_blocks_dir}"/ ]; then
  if [ "$(uname -s)" = "Darwin" ]; then
    blocks_size_in_mib=$(du -d0 -m "${bitcoin_core_blocks_dir}" | cut -f1)
  else
    blocks_size_in_mib=$(du -d0 --block-size="1MiB" "${bitcoin_core_blocks_dir}" | cut -f1)
  fi
fi
if [ -d "${bitcoin_core_chainstate_dir}"/ ]; then
  if [ "$(uname -s)" = "Darwin" ]; then
    chainstate_size_in_mib=$(du -d0 -m "${bitcoin_core_chainstate_dir}" | cut -f1)
  else
    chainstate_size_in_mib=$(du -d0 --block-size="1MiB" "${bitcoin_core_chainstate_dir}" | cut -f1)
  fi
fi
data_already_synced_in_mib=$((blocks_size_in_mib + chainstate_size_in_mib))
printf '%s\n' "$((data_already_synced_in_mib / MIB_TO_GIB)) GiB."

printf '%s' "Checking free space in home directory... "
free_space_in_mib="$(get_free_space_in_mib)"
printf '%s\n' "$((free_space_in_mib / MIB_TO_GIB)) GiB."

## This constant will need to be adjusted over time as the chain grows
## or need to find how to generate this dynamically in a trustless way.
## The lower this number is, the more likely disk space errors during IBD.
## The higher this number is, the more likely a node will be to prune.
## The sweet spot is about 50 to 100 GB more than the size of blocks/ + chainstate/,
## which, as of June 2023, is around 522 GiB.
archival_node_required_disk_in_gib="686"
archival_node_required_disk_in_mib=$((archival_node_required_disk_in_gib * MIB_TO_GIB))

# check if the user wants to disable pruning
if [ "${prune_value}" -eq 0 ]; then
  if [ "$((data_already_synced_in_mib + free_space_in_mib))" -lt "${archival_node_required_disk_in_mib}" ]; then
    throw_error "Not enough storage to disable pruning. Free up ${archival_node_required_disk_in_gib} GiB or use a positive value less than $((data_already_synced_in_mib + free_space_in_mib)) \(MiB\)."
  fi
  printf '  %s' "Configuring with the disabled prune option... "
  set_bitcoin_core_option "prune" "${prune_value}"
  printf '%s\n' "ok."
# check if the user passed in a prune value
elif [ "${prune_value}" -gt 0 ]; then
  if [ "$((data_already_synced_in_mib + free_space_in_mib))" -lt "${prune_value}" ]; then
    throw_error "Prune value ${prune_value} too large. Run without setting prune or use a value less than $((data_already_synced_in_mib + free_space_in_mib)) \(MiB\)."
  fi
  printf '  %s' "Configuring with the ${prune_value} MiB prune option... "
  set_bitcoin_core_option "prune" "${prune_value}"
  printf '%s\n' "ok."
# check that a prune value doesn't already exist in the config file
elif [ "$(grep -c -i "^prune=" "${bitcoin_core_config_file}")" = "0" ]; then
  if [ "${free_space_in_mib}" -ge $((archival_node_required_disk_in_mib - data_already_synced_in_mib)) ]; then
    printf '  %s\n' "Your node will run as an unpruned full node."
    set_bitcoin_core_option "prune" "0"
  elif [ "${free_space_in_mib}" -lt $((archival_node_required_disk_in_mib / 80 - data_already_synced_in_mib)) ]; then
    throw_error "You are too low on disk space to run Bitcoin Core."
  else
    if [ "${free_space_in_mib}" -lt $((archival_node_required_disk_in_mib / 40 - data_already_synced_in_mib)) ]; then
      printf '  %s\n  %s\n' "Your disk space is low." "Setting blocks-only mode and the minimum 0.55 GiB prune."
      set_bitcoin_core_option "blocksonly" "1"
      prune_amount_in_mib="550"
    else
      if [ "${free_space_in_mib}" -lt $((archival_node_required_disk_in_mib / 12 - data_already_synced_in_mib)) ]; then
        prune_ratio=20
      elif [ "${free_space_in_mib}" -lt $((archival_node_required_disk_in_mib / 4 - data_already_synced_in_mib)) ]; then
        prune_ratio=40
      elif [ "${free_space_in_mib}" -lt $((archival_node_required_disk_in_mib * 3 / 4 - data_already_synced_in_mib)) ]; then
        prune_ratio=60
      else
        prune_ratio=80
      fi
      prune_amount_in_mib=$((free_space_in_mib * prune_ratio / 100))
      printf '  Pruning to %d GiB (%d%% of the free space).\n  You can change this in ~/.bitcoin/bitcoin.conf.\n' "$((prune_amount_in_mib / MIB_TO_GIB))" "${prune_ratio}"
    fi
    set_bitcoin_core_option "prune" "${prune_amount_in_mib}"
  fi
fi

printf '%s' "Starting Bitcoin Core... "
if is_running_in_ci ||
  is_running_in_container ||
  ! command -v bitcoin-qt > /dev/null 2>&1; then
  bitcoind --daemonwait > /dev/null
elif [ "$(uname -s)" = "Darwin" ]; then
  nohup bitcoin-qt > /dev/null 2>&1 < /dev/null &
else
  setsid bitcoin-qt > /dev/null 2>&1 < /dev/null &
fi

printf '%s\n  %s' "ok." "Checking the RPC status... "
rpc_timeout=60
if ! bitcoin-cli --rpcwait --rpcwaittimeout="${rpc_timeout}" getrpcinfo > /dev/null; then
  throw_error "RPC communication failed after ${rpc_timeout} seconds"
fi
printf '%s\n' "ok."

sleep_time="10"
blockchain_info=$(bitcoin-cli --rpcwait getblockchaininfo)
ibd_status=$(echo "${blockchain_info}" | jq '.initialblockdownload')

if [ "${ibd_status}" = true ]; then
  if ! is_running_in_container; then
    printf '%s' "Disabling system sleep, suspend, and hibernate... "
    if [ "$(uname -s)" = "Darwin" ]; then
      caffeinate -sw "$(cat ~/Library/Application\ Support/Bitcoin/bitcoind.pid)" &
    else
      sudo systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target > /dev/null 2>&1
    fi
    printf '%s\n%s\n%s' \
      "ok." \
      "Close this Terminal window by clicking on the \"X\"." \
      "This screen will refresh in ${sleep_time} seconds."
  fi
  i=1
  while [ "$i" -le 10 ]; do
    sleep 1
    printf '%s' "."
    i=$((i + 1))
  done
  printf '\n'
else
  printf '  %s\n' "Your node has already synced the blockchain."
fi

while [ "${ibd_status}" = true ]; do
  blocks=$(echo "${blockchain_info}" | jq '.blocks')
  headers=$(echo "${blockchain_info}" | jq '.headers')
  last_block_time=$(echo "${blockchain_info}" | jq '.time')
  size_on_disk_in_mib=$(($(echo "${blockchain_info}" | jq '.size_on_disk') / BYTES_TO_KIB / KIB_TO_MIB))
  sync_progress=$(echo "${blockchain_info}" | jq '.verificationprogress')

  # Handle case of early sync by replacing scientific notation with decimal
  if [ "$(printf '%s\n' "${sync_progress}" | grep -c -i "e")" -gt 0 ]; then
    sync_progress="0.000000001"
  fi
  sync_progress_percent="$(awk -v prog="${sync_progress}" 'BEGIN{printf "%f\n", prog * 100}')"

  free_space_in_mib=$(get_free_space_in_mib)

  clear
  if [ "${headers}" -eq 0 ]; then
    printf '%s\n' 'Syncing the block headers (first pass).'
  elif [ "${blocks}" -eq 0 ]; then
    printf '%s\n' 'Syncing the block headers (second pass).'
    printf 'Headers synced:     %d\n' "${headers}"
  else
    printf 'Sync progress:      %.3f %%\n' "${sync_progress_percent}"
    printf 'Blocks remaining:   %d\n' "$((headers - blocks))"

    if [ "$(uname -s)" = "Darwin" ]; then
      printf 'Current chain tip:  %s\n' "$(/bin/date -r "${last_block_time}" | cut -c 5-)"
    else
      printf 'Current chain tip:  %s\n' "$(date -d @"${last_block_time}" | cut -c 5-)"
    fi

    printf '%s' 'Chain sync size:    '
    if [ "${size_on_disk_in_mib}" -gt "${MIB_TO_GIB}" ]; then
      printf '%d GiB\n' "$((size_on_disk_in_mib / MIB_TO_GIB))"
    else
      printf '%d MiB\n' "${size_on_disk_in_mib}"
    fi
  fi

  printf '%s' 'Disk free space:    '
  if [ "${free_space_in_mib}" -gt "${MIB_TO_GIB}" ]; then
    printf '%d GiB\n' "$((free_space_in_mib / MIB_TO_GIB))"
  else
    printf '%d MiB\n' "${free_space_in_mib}"
  fi

  if [ "${size_on_disk_in_mib}" -ge 1 ] && (is_running_in_ci || is_running_in_container); then
    printf '%s\n' "The blockchain download is progressing. Exiting the script."
    exit 0
  fi

  printf '%s\n\n' "Synchronizing can take weeks on a slow connection."
  printf '%s\n' "Close this Terminal window by clicking on the \"X\"."
  printf '%s' "This screen will refresh in ${sleep_time} seconds."
  sleep "${sleep_time}"

  blockchain_info=$(bitcoin-cli --rpcwait getblockchaininfo)
  printf '\n'
  ibd_status=$(echo "${blockchain_info}" | jq '.initialblockdownload')
done

printf '%s\n' "This script has completed successfully."
exit 0
